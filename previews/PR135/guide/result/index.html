<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Results · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li class="is-active"><a class="tocitem" href>Results</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Termination-Queries"><span>Termination Queries</span></a></li><li><a class="tocitem" href="#Variable-Queries"><span>Variable Queries</span></a></li><li><a class="tocitem" href="#Constraint-Queries"><span>Constraint Queries</span></a></li><li><a class="tocitem" href="#LP-Sensitivity"><span>LP Sensitivity</span></a></li><li><a class="tocitem" href="#Other-Queries"><span>Other Queries</span></a></li><li><a class="tocitem" href="#Methods/DataTypes"><span>Methods/DataTypes</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Results</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Results</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/result.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h1><p>A guide and manual to querying optimized <code>InfiniteOpt</code> models. The Methods  section at the bottom comprises the manual and the above sections form the  guide.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>So far we have covered defining, transforming, and optimizing <code>InfiniteModel</code>s.  Now comes the point to extract information from our optimized model. This is done  following extended versions of <code>JuMP</code>s querying functions in combination with  the mapping information stored in the optimizer model. Thus, this page will  walk through the use of these result query functions.</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Let&#39;s revisit the example from the optimization page to get us started:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, Ipopt;

julia&gt; model = InfiniteModel(Ipopt.Optimizer);

julia&gt; set_optimizer_attribute(model, &quot;print_level&quot;, 0);

julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10);

julia&gt; @variable(model, y &gt;= 0, Infinite(t));

julia&gt; @variable(model, z &gt;= 0);

julia&gt; @objective(model, Min, 2z);

julia&gt; @constraint(model, c1, z &gt;= y);

julia&gt; @constraint(model, c2, y == 42, DomainRestrictions(t =&gt; 0));

julia&gt; print(model)
Min 2 z
Subject to
 y(t) ≥ 0.0, ∀ t ∈ [0, 10]
 z ≥ 0
 c1 : z - y(t) ≥ 0.0, ∀ t ∈ [0, 10]
 c2 : y(t) = 42.0, ∀ t = 0

julia&gt; optimize!(model)
</code></pre><p>Now that the model has been optimized, let&#39;s find out what happened. To determine  why the optimizer stopped, we can use  <a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a> to report the corresponding <code>MathOptInterface</code>  termination code (possible codes are explained  <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#MathOptInterface.TerminationStatusCode">here</a>.</p><pre><code class="language-julia-repl">julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4</code></pre><p>Here we see that our model was locally solved via Ipopt and that is why it  stopped. Furthermore, we can query the primal and dual problem optimalities via  <a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a> and  <a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, respectively.</p><pre><code class="language-julia-repl">julia&gt; primal_status(model)
FEASIBLE_POINT::ResultStatusCode = 1

julia&gt; dual_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre><p>The possible statuses are detailed <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#MathOptInterface.ResultStatusCode">here</a>.  These results are useful in knowing if information can be drawn from the primal  and/or dual and what it means. We can also verify that we indeed have answers  via <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a> which indicates if our model has optimized variable  values.</p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre><p>And indeed we do have values.</p><p>Now we can query the objective value via <a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a> which reports the optimal objective value.</p><pre><code class="language-julia-repl">julia&gt; objective_value(model)
83.99999998250514</code></pre><p>Great now we can inquire about variable values via  <a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a>. First, let&#39;s retrieve the value of <code>z</code>:</p><pre><code class="language-julia-repl">julia&gt; value(z)
41.99999999125257</code></pre><p>We get a single value since <code>z</code> is a <code>FiniteVariable</code> and therefore finite. Now  let&#39;s retrieve the &quot;value&quot; of <code>y(t)</code> which is infinite with respect to <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; value(y)
10-element Array{Float64,1}:
 42.0
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495</code></pre><p>Notice here we obtain an array of values since these correspond to the  transcribed finite (discretized) variables used to solve the problem. We obtain  the corresponding support (discretized <code>t</code>) values via <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; supports(y)
10-element Array{Tuple,1}:
 (0.0,)
 (1.11111111111,)
 (2.22222222222,)
 (3.33333333333,)
 (4.44444444444,)
 (5.55555555556,)
 (6.66666666667,)
 (7.77777777778,)
 (8.88888888889,)
 (10.0,)</code></pre><p>There is 1-to-1 correspondence between these supports and the values reported  above. Note that these are stored in tuples to facilitate multiple infinite  parameter dependencies.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The values for an array of variables is obtained via the vectorized call  of <code>value</code> following the syntax:</p><pre><code class="language-julia">value.(::AbstractArray{&lt;:GeneralVariableRef})</code></pre><p>This also holds true for many other methods in <code>InfiniteOpt</code>. For example,  adding the dot also vectorizes <code>dual</code> and <code>set_binary</code>.</p></div></div><p>We can also query the dual of a constraint via  <a href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>dual</code></a> if a model has duals available as indicated by <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true

julia&gt; dual(c1)
10-element Array{Float64,1}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p><code>c1</code> is an infinite constraint and thus we obtain the duals of its transcribed  versions. The underlying infinite parameter(s) and support values are queried  via <code>parameter_refs</code> and <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; parameter_refs(c1)
(t,)

julia&gt; supports(c1)
10-element Array{Tuple,1}:
 (0.0,)
 (1.11111111111,)
 (2.22222222222,)
 (3.33333333333,)
 (4.44444444444,)
 (5.55555555556,)
 (6.66666666667,)
 (7.77777777778,)
 (8.88888888889,)
 (10.0,)</code></pre><p>These again all have a 1-to-1 correspondence.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the case that our variables/constraints depend on multiple infinite  parameter it is typically convenient to add the keyword statement  <code>ndarray = true</code> when calling any variable/constraint queries (e.g., <code>value</code>  and <code>dual</code>). This will reformat the output vector into a n-dimensional array  whose dimensions correspond to the supports of the infinite parameters. </p></div></div><h2 id="Termination-Queries"><a class="docs-heading-anchor" href="#Termination-Queries">Termination Queries</a><a id="Termination-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-Queries" title="Permalink"></a></h2><p>Termination queries are those that question about how the infinite model was  solved and what its optimized state entails. Programmatically, such queries on  the <code>InfiniteModel</code> are simply routed to its optimizer model.</p><p>The commonly used queries include <a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a>,  <a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a>, <a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, <a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a>, <a href="#JuMP.result_count-Tuple{InfiniteModel}"><code>result_count</code></a>, and <a href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>solve_time</code></a>. The first four are well  exemplified in the Basic Usage section above and are helpful in quickly  understanding the optimality status of a given model following the many possible  statuses reported by <code>MathOptInterface</code> which are documented  <a href="https://jump.dev/MathOptInterface.jl/v0.9.22/manual/solutions/#Solutions">here</a>.  We use <code>result_count</code> to determine how many solutions are recorded in the  optimizer.</p><pre><code class="language-julia-repl">julia&gt; result_count(model)
1</code></pre><p>This is useful since it informs what results there are which can be specified  via the <code>result</code> keyword argument in many methods such as <code>primal_status</code>,  <code>dual_status</code>, <code>objective_value</code>, <code>value</code>, <code>dual</code>, and more.</p><p>We use <code>solve_time</code> to determine the time in seconds used by the optimizer until  it terminated its search.</p><pre><code class="language-julia-repl">julia&gt; solve_time(model)
0.004999876022338867</code></pre><p>Note that this query might not be supported with all solvers.</p><p>The above status queries are designed to report information in a consistent  format irrespective of the chosen optimizer. However, <a href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>raw_status</code></a> will  provide the optimality status verbatim as reported by the optimizer. Thus,  following our example with Ipopt we obtain:</p><pre><code class="language-julia-repl">julia&gt; raw_status(model)
&quot;Solve_Succeeded&quot;</code></pre><p>Also, we obtain the best objective bound via <a href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>objective_bound</code></a> which  becomes particularly useful solutions that are suboptimal. However, this method  is not supported by all optimizers and in this case Ipopt is one such optimizer.</p><p>Finally, we get the best dual objective value via <a href="#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>dual_objective_value</code></a>  if the optimizer supplies this information which again Ipopt does not.</p><h2 id="Variable-Queries"><a class="docs-heading-anchor" href="#Variable-Queries">Variable Queries</a><a id="Variable-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Queries" title="Permalink"></a></h2><p>Information about the optimized variables is gathered consistently in comparison  to typical <code>JuMP</code> models. With <code>InfiniteModel</code>s this is done by querying the  optimizer model and using its stored variable mappings to return the correct  information. Thus, here the queries are extended to work with the specifics of  the optimizer model to return the appropriate info.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Like <code>supports</code> the all variable based query methods below also employ the  <code>label::Type{AbstractSupportLabel} = PublicLabel</code> keyword argument that by  default will return the desired information associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via <code>label = All</code>.</li><li>These methods also employ the <code>ndarray::Bool</code> keyword argument that will cause the  output to be formatted as a n-dimensional array where the dimensions  correspond to the infinite parameter dependencies. For example, if we have an  infinite variable <code>y(t, ξ)</code> and we invoke a query method with <code>ndarray = true</code>  then we&#39;ll get a matrix whose dimensions correspond to the supports of <code>t</code> and  <code>ξ</code>, respectively. Also, if <code>ndarray = true</code> then <code>label</code> correspond to the  intersection of supports labels in contrast to its default of invoking the union  of the labels.</li></ol></div></div><p>First, we should verify that the optimized model in fact has variable values  via <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a>. In our example, we have:</p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre><p>So we have values readily available to be extracted.</p><p>Now <a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a> can be used to query the  values as shown above in the Basic Usage section. This works by calling the  appropriate <a href="#InfiniteOpt.map_value"><code>map_value</code></a> defined by the optimizer  model. By default this, employs the <code>map_value</code> fallback which uses  <code>optimizer_model_variable</code> to do the mapping. Details on how to extend these  methods for user-defined optimizer models is explained on the Extensions page.</p><p>We also, support call to <code>value</code> that use an expression of variables as input.</p><p>Finally, the optimizer index of a variable is queried via  <a href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>optimizer_index</code></a> which  reports back the index of the variable as used in the <code>MathOptInterface</code>  backend:</p><pre><code class="language-julia-repl">julia&gt; optimizer_index(z)
MathOptInterface.VariableIndex(1)

julia&gt; optimizer_index(y)
10-element Array{MathOptInterface.VariableIndex,1}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)
 MathOptInterface.VariableIndex(6)
 MathOptInterface.VariableIndex(7)
 MathOptInterface.VariableIndex(8)
 MathOptInterface.VariableIndex(9)
 MathOptInterface.VariableIndex(10)
 MathOptInterface.VariableIndex(11)</code></pre><p>As noted previously, an array is returned for <code>y(t)</code> in accordance with its  transcription variables. In similar manner to <code>value</code>, this is enabled by  appropriate versions of <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a>.</p><h2 id="Constraint-Queries"><a class="docs-heading-anchor" href="#Constraint-Queries">Constraint Queries</a><a id="Constraint-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Queries" title="Permalink"></a></h2><p>Like variables, a variety of information can be queried about constraints.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Like <code>supports</code> the all constraint query methods below also employ the  <code>label::Type{AbstractSupportLabel} = PublicLabel</code> keyword argument that by  default will return the desired information associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via <code>label = All</code>.</li><li>These methods also employ the <code>ndarray::Bool</code> keyword argument that will cause the  output to be formatted as a n-dimensional array where the dimensions  correspond to the infinite parameter dependencies. For example, if we have an  infinite constraint that depends on <code>t</code> and <code>ξ)</code> and we invoke a query method  with <code>ndarray = true</code> then we&#39;ll get a matrix whose dimensions correspond to  the supports of <code>t</code> and <code>ξ</code>, respectively. Also, if <code>ndarray = true</code> then  <code>label</code> correspond to the intersection of supports labels in contrast to its  default of invoking the union of the labels.</li></ol></div></div><p>First, recall that constraints are stored in the form <code>function-in-set</code> where  generally <code>function</code> contains the variables and coefficients and the set contains  the relational operator and the constant value. With this understanding, we  query the value of a constraint&#39;s <code>function</code> via  <a href="#JuMP.value-Tuple{InfOptConstraintRef}"><code>value</code></a>:</p><pre><code class="language-julia-repl">julia&gt; constraint_object(c1).func # show the function expression of c1
z - y(t)

julia&gt; value(c1)
10-element Array{Float64,1}:
 -8.747427671096375e-9
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077</code></pre><p>Again, we obtain an array of values since <code>c1</code> is infinite due to its dependence  on <code>x(t)</code>. Behind the scenes this is implemented via the appropriate extensions  of <a href="#InfiniteOpt.map_value"><code>map_value</code></a>.</p><p>Next the optimizer index(es) of the transcribed constraints in the  <code>MathOptInterface</code> backend provided via  <a href="#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>optimizer_index</code></a>.</p><pre><code class="language-julia-repl">julia&gt; optimizer_index(c1)
10-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(5)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(6)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(7)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(8)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(9)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(10)</code></pre><p>Here 10 indices are given in accordance with the transcription constraints.  The mapping between these and the original infinite constraints is managed via  the appropriate extensions of <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a>.</p><p>We can also query dual information from our constraints if it is available.  First, we should verify that dual information is available via  <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true</code></pre><p>Now we can query the duals via <a href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>dual</code></a>.</p><pre><code class="language-julia-repl">julia&gt; dual(c1)
10-element Array{Float64,1}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p>Here we obtain the optimal dual values for each transcribed version of <code>c1</code>. This  is enabled via the proper extensions of <a href="#InfiniteOpt.map_dual"><code>map_dual</code></a>.</p><p>Finally, we query the shadow price of a constraint via  <a href="#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>shadow_price</code></a>. This denotes  the change in the objective value due to an infinitesimal relaxation of the  constraint. For <code>c1</code> we get:</p><pre><code class="language-julia-repl">julia&gt; shadow_price(c1)
10-element Array{Float64,1}:
 -1.9999999988666093
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10</code></pre><p>Similarly, the mapping to the transcription constraints is enabled via the  appropriate version of <a href="#InfiniteOpt.map_shadow_price"><code>map_shadow_price</code></a>.</p><h2 id="LP-Sensitivity"><a class="docs-heading-anchor" href="#LP-Sensitivity">LP Sensitivity</a><a id="LP-Sensitivity-1"></a><a class="docs-heading-anchor-permalink" href="#LP-Sensitivity" title="Permalink"></a></h2><p>We also conduct sensitivity analysis for linear problems using  <a href="#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}"><code>lp_sensitivity_report</code></a>. This  will generate a <a href="#InfiniteOpt.InfOptSensitivityReport"><code>InfOptSensitivityReport</code></a> which contains mapping to the  ranges indicating how much a constraint RHS constant or a objective  coefficient can be changed without violating the feasibility of the solution.  This is further explained in the JuMP documentation  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/solutions/#Sensitivity-analysis-for-LP">here</a>.  Furthermore, these analysis can only be employed for a solver that implements  <code>MOI.ConstraintBasisStatus</code>. In our running example up above, <code>Ipopt.jl</code> does not  support this A solver like <code>Gurobi.jl</code> does.</p><pre><code class="language-julia-repl">julia&gt; report = lp_sensitivity_report(model);

julia&gt; report[c1]
10-element Array{Tuple{Float64,Float64},1}:
 (-42.0, Inf)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)

julia&gt; report[z]
(-2.0, Inf)</code></pre><p>Note that like other query methods, an array of ranges will be provided with testing the sensitivity of an infinite constraint RHS in accordance with the discretization scheme. Also, keyword arguments (like <code>ndarray</code> and <code>label</code>) can  be invoked when indexing the report:</p><pre><code class="language-julia-repl">julia&gt; report[c1, label = All]
10-element Array{Tuple{Float64,Float64},1}:
 (-42.0, Inf)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)</code></pre><h2 id="Other-Queries"><a class="docs-heading-anchor" href="#Other-Queries">Other Queries</a><a id="Other-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Queries" title="Permalink"></a></h2><p>Any other queries supported by <code>JuMP</code> can be accessed by simply interrogating the  optimizer model directly using <a href="../optimize/#InfiniteOpt.optimizer_model"><code>optimizer_model</code></a> to access it. For  example, we can get the solution summary of the optimizer model:</p><pre><code class="language-julia-repl">julia&gt; solution_summary(optimizer_model(model))
* Solver : Ipopt

* Status
  Termination status : LOCALLY_SOLVED
  Primal status      : FEASIBLE_POINT
  Dual status        : FEASIBLE_POINT
  Message from the solver:
  &quot;Solve_Succeeded&quot;

* Candidate solution
  Objective value      : 83.99999998250514

* Work counters
  Solve time (sec)   : 0.01000</code></pre><h2 id="Methods/DataTypes"><a class="docs-heading-anchor" href="#Methods/DataTypes">Methods/DataTypes</a><a id="Methods/DataTypes-1"></a><a class="docs-heading-anchor-permalink" href="#Methods/DataTypes" title="Permalink"></a></h2><ul><li><a href="#JuMP.barrier_iterations-Tuple{InfiniteModel}"><code>JuMP.barrier_iterations</code></a></li><li><a href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>JuMP.dual</code></a></li><li><a href="#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>JuMP.dual_objective_value</code></a></li><li><a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a></li><li><a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a></li><li><a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a></li><li><a href="#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}"><code>JuMP.lp_sensitivity_report</code></a></li><li><a href="#JuMP.node_count-Tuple{InfiniteModel}"><code>JuMP.node_count</code></a></li><li><a href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a></li><li><a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a></li><li><a href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>JuMP.optimizer_index</code></a></li><li><a href="#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>JuMP.optimizer_index</code></a></li><li><a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a></li><li><a href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>JuMP.raw_status</code></a></li><li><a href="#JuMP.reduced_cost-Tuple{GeneralVariableRef}"><code>JuMP.reduced_cost</code></a></li><li><a href="#JuMP.relative_gap-Tuple{InfiniteModel}"><code>JuMP.relative_gap</code></a></li><li><a href="#JuMP.result_count-Tuple{InfiniteModel}"><code>JuMP.result_count</code></a></li><li><a href="#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>JuMP.shadow_price</code></a></li><li><a href="#JuMP.simplex_iterations-Tuple{InfiniteModel}"><code>JuMP.simplex_iterations</code></a></li><li><a href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>JuMP.solve_time</code></a></li><li><a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a></li><li><a href="#JuMP.value-Tuple{InfOptConstraintRef}"><code>JuMP.value</code></a></li><li><a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a></li><li><a href="#JuMP.value-Tuple{Union{GenericAffExpr{#s380,#s14} where #s14&lt;:GeneralVariableRef where #s380, GenericQuadExpr{#s5,#s2} where #s2&lt;:GeneralVariableRef where #s5}}"><code>JuMP.value</code></a></li><li><a href="#InfiniteOpt.map_dual"><code>InfiniteOpt.map_dual</code></a></li><li><a href="#InfiniteOpt.map_optimizer_index"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="#InfiniteOpt.map_reduced_cost"><code>InfiniteOpt.map_reduced_cost</code></a></li><li><a href="#InfiniteOpt.map_shadow_price"><code>InfiniteOpt.map_shadow_price</code></a></li><li><a href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a></li><li><a href="#InfiniteOpt.InfOptSensitivityReport"><code>InfiniteOpt.InfOptSensitivityReport</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="JuMP.termination_status-Tuple{InfiniteModel}" href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.termination_status(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.termination_status"><code>JuMP.JuMP.termination_status</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.raw_status-Tuple{InfiniteModel}" href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>JuMP.raw_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.raw_status(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.raw_status"><code>JuMP.JuMP.raw_status</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.primal_status-Tuple{InfiniteModel}" href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.primal_status(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.primal_status"><code>JuMP.JuMP.primal_status</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_status-Tuple{InfiniteModel}" href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.dual_status(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.dual_status"><code>JuMP.JuMP.dual_status</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solve_time-Tuple{InfiniteModel}" href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>JuMP.solve_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.solve_time(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.solve_time"><code>JuMP.JuMP.solve_time</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_values-Tuple{InfiniteModel}" href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.has_values(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.has_values"><code>JuMP.JuMP.has_values</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_duals-Tuple{InfiniteModel}" href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.has_duals(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.has_duals"><code>JuMP.JuMP.has_duals</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.simplex_iterations-Tuple{InfiniteModel}" href="#JuMP.simplex_iterations-Tuple{InfiniteModel}"><code>JuMP.simplex_iterations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.simplex_iterations(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.simplex_iterations"><code>JuMP.JuMP.simplex_iterations</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.barrier_iterations-Tuple{InfiniteModel}" href="#JuMP.barrier_iterations-Tuple{InfiniteModel}"><code>JuMP.barrier_iterations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.barrier_iterations(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.barrier_iterations"><code>JuMP.JuMP.barrier_iterations</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.node_count-Tuple{InfiniteModel}" href="#JuMP.node_count-Tuple{InfiniteModel}"><code>JuMP.node_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.node_count(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.node_count"><code>JuMP.JuMP.node_count</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_bound-Tuple{InfiniteModel}" href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.objective_bound(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.objective_bound"><code>JuMP.JuMP.objective_bound</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_value-Tuple{InfiniteModel}" href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.objective_value(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.objective_value"><code>JuMP.JuMP.objective_value</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_objective_value-Tuple{InfiniteModel}" href="#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>JuMP.dual_objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.dual_objective_value(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.dual_objective_value"><code>JuMP.JuMP.dual_objective_value</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.result_count-Tuple{InfiniteModel}" href="#JuMP.result_count-Tuple{InfiniteModel}"><code>JuMP.result_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.result_count(model::InfiniteModel)</code></pre><p>Extend <code>result_count</code> to return the number of results available to query after a  call to <code>optimize!</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repla">julia&gt; result_count(model)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/optimize.jl#LL437-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.relative_gap-Tuple{InfiniteModel}" href="#JuMP.relative_gap-Tuple{InfiniteModel}"><code>JuMP.relative_gap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.JuMP.relative_gap(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.JuMP.relative_gap"><code>JuMP.JuMP.relative_gap</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{GeneralVariableRef}" href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(vref::GeneralVariableRef; [result::Int = 1, 
           label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
           ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.value</code> to return the value(s) of <code>vref</code> in accordance with its  reformulation variable(s) stored in the optimizer model and the result index  <code>result</code> of the most recent solution obtained. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the values associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the values of infinite  variables are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the variable has multiple  infinite parameter dependencies.</p><p>To provide context for the results it may be helpful to also query the variable&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> to retrieve the variables(s) that these values are based on. These functions should  all be called with the same keyword arugments for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(z)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL109-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{InfOptConstraintRef}" href="#JuMP.value-Tuple{InfOptConstraintRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(cref::InfOptConstraintRef; [result::Int = 1,
           label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
           ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.value</code> to return the value(s) of <code>cref</code> in accordance with its  reformulation constraint(s) stored in the optimizer model and the result index  <code>result</code> of the most recent solution obtained. Use  <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result  exists before asking for values. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the values associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the values of infinite  constraints are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the constraint has multiple  infinite parameter dependencies.</p><p>To provide context for the results it may be helpful to also query the constraint&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these values are based on. By default, only the  values corresponding to public supports are returned. These functions should  all be called with the same keyword arugments for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for constraints. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(c1)
4-element Array{Float64,1}:
 -0.0
 20.9
 20.9
 20.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL150-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{Union{GenericAffExpr{#s380,#s14} where #s14&lt;:GeneralVariableRef where #s380, GenericQuadExpr{#s5,#s2} where #s2&lt;:GeneralVariableRef where #s5}}" href="#JuMP.value-Tuple{Union{GenericAffExpr{#s380,#s14} where #s14&lt;:GeneralVariableRef where #s380, GenericQuadExpr{#s5,#s2} where #s2&lt;:GeneralVariableRef where #s5}}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">value(ex::GenericAffExpr, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div></section><section><div><pre><code class="language-none">JuMP.value(expr::JuMP.AbstractJuMPScalar; [result::Int = 1, 
           label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
           ndarray::Bool = false, kwargs...])</code></pre><p>Return the value(s) of <code>expr</code> in accordance with the optimized variable values the result index <code>result</code> of the most recent solution obtained. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the values associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the values of infinite  expressions are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the expression has multiple  infinite parameter dependencies.</p><p>To provide context for the results it may be helpful to also query the expression&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_expression"><code>optimizer_model_expression</code></a> to retrieve the expression(s) that these values are based on. These should use the same keyword arguments for  consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_expression"><code>optimizer_model_expression</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for expressions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(my_finite_expr)
23.34

julia&gt; value(my_infinite_expr)
4-element Array{Float64,1}:
 -0.0
 20.9
 20.9
 20.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL198-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.reduced_cost-Tuple{GeneralVariableRef}" href="#JuMP.reduced_cost-Tuple{GeneralVariableRef}"><code>JuMP.reduced_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.reduced_cost(vref::GeneralVariableRef)</code></pre><p>Extend <code>JuMP.reduced_cost</code>. This returns the reduced cost(s) of a variable. This  will be a vector of scalar values for an infinite variable or will be a scalar  value for finite variables. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; reduced_cost(x)
12.81</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL284-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{GeneralVariableRef}" href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimizer_index(vref::GeneralVariableRef; 
                     [label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
                     ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.optimizer_index</code> to return the <code>MathOptInterface</code> index(es) of  <code>vref</code> in accordance with its reformulation variable(s) stored in the optimizer  model.</p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the optimizer indices associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the indices of infinite  variables are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the variable has multiple  infinite parameter dependencies.</p><p>It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> to retrieve the variables(s) that these indices are based on. These should use the  same keyword arguments for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a> has been extended for variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_index(x)
4-element Array{MathOptInterface.VariableIndex,1}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL340-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{InfOptConstraintRef}" href="#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimizer_index(cref::InfOptConstraintRef; 
                     [label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
                     ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.optimizer_index</code> to return the <code>MathOptInterface</code> index(es) of  <code>cref</code> in accordance with its reformulation constraints(s) stored in the  optimizer model. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the optimizer indices associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the indices of infinite  constraints are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the constraint has multiple  infinite parameter dependencies.</p><p>It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraints(s) that these indices are based on. The same keyword  arguments should be used for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a> has been extended for constraints.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_index(c1)
4-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL381-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual-Tuple{InfOptConstraintRef}" href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>JuMP.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual(cref::InfOptConstraintRef; [result::Int = 1, 
          label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
          ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.dual</code> to return the dual(s) of <code>cref</code> in accordance with its  reformulation constraint(s) stored in the optimizer model and the result index  <code>result</code> of the most recent solution obtained. Use  <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> to check if a result  exists before asking for duals. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the duals associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the duals of infinite  constraints are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the constraint has multiple  infinite parameter dependencies.</p><p>It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these duals are based on. Calling <code>parameter_refs</code> and <code>supports</code> may also be insightful. Be sure to use the same keyword arguments for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_dual"><code>map_dual</code></a> has been extended for constraints.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dual(c1)
4-element Array{Float64,1}:
 -42.0
 -42.0
 32.3
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL452-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.shadow_price-Tuple{InfOptConstraintRef}" href="#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>JuMP.shadow_price</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.shadow_price(cref::InfOptConstraintRef; 
                  [label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
                  ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.shadow_price</code> to return the shadow price(s) of <code>cref</code> in accordance  with its reformulation constraint(s) stored in the optimizer model. Use  <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> to check if a result  exists before asking for duals. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the shadow prices associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the prices of infinite  constraints are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the constraint has multiple  infinite parameter dependencies.</p><p>It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these shadow prices are based on. Calling <code>parameter_refs</code> and <code>supports</code> may also be insightful. Be sure to use the same keyword arguments for  consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_shadow_price"><code>map_shadow_price</code></a> has been extended for constraints. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; shadow_price(c1)
4-element Array{Float64,1}:
 42.0
 42.0
 -32.3
 -0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL530-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_sensitivity_report-Tuple{InfiniteModel}" href="#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}"><code>JuMP.lp_sensitivity_report</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lp_sensitivity_report(model::InfiniteModel; 
                           [atol::Float64 = 1e-8])::InfOptSensitivityReport</code></pre><p>Extends <code>JuMP.lp_sensitivity_report</code> to generate and return an LP sensitivity  report in accordance with the optimizer model. See  <a href="#InfiniteOpt.InfOptSensitivityReport"><code>InfOptSensitivityReport</code></a> for syntax details on how to query it. <code>atol</code>  denotes the optimality tolerance and should match that used by the solver to  compute the basis. Please refer to <code>JuMP</code>&#39;s documentation for more technical  information on interpretting the output of the report.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; report = lp_sensitivity_report(model);

julia&gt; report[x]
(0.0, 0.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL623-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptSensitivityReport" href="#InfiniteOpt.InfOptSensitivityReport"><code>InfiniteOpt.InfOptSensitivityReport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfOptSensitivityReport</code></pre><p>A wrapper <code>DataType</code> for <code>JuMP.SensitivityReport</code>s in <code>InfiniteOpt</code>.  These are generated based on the optimizer model and should be made via the use of  <a href="#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}"><code>lp_sensitivity_report</code></a>. Once  made these can be indexed to get the sensitivies with respect to variables and/or  constraints. The indexing syntax for these is: </p><pre><code class="language-julia">report[ref::[GeneralVariableRef/InfOptConstraintRef]; 
       [label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
       ndarray::Bool = false, kwargs...]]</code></pre><p>This is enabled in user-defined optimizer model extensions by appropriately  extending <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> and <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>opt_report::JuMP.SensitivityReport</code>: The LP sensitivity captured from the optimizer model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL577-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_value" href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_value([ref/expr], key::Val{ext_key_name}, result::Int; kwargs...)</code></pre><p>Map the value(s) of <code>ref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code>, <code>optimizer_model_expression</code>, and/or <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code>, <code>optimizer_model_expression</code>, and <code>optimizer_model_constraint</code> are used to make these mappings by default where <code>kwargs</code> are passed on these functions. Here  <code>result</code> is the result index used in <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL44-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_optimizer_index" href="#InfiniteOpt.map_optimizer_index"><code>InfiniteOpt.map_optimizer_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_optimizer_index(ref, key::Val{ext_key_name}; kwargs...)</code></pre><p>Map the <code>MathOptInterface</code> index(es) of <code>ref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default where <code>kwargs</code> are passed on as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL305-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_dual" href="#InfiniteOpt.map_dual"><code>InfiniteOpt.map_dual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_dual(cref::InfOptConstraintRef, key::Val{ext_key_name}, result::Int; 
         kwargs...)</code></pre><p>Map the dual(s) of <code>cref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default where <code>kwargs</code> are also pass on to. Here <code>result</code> is  the result index that is used in <code>dual</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL425-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_shadow_price" href="#InfiniteOpt.map_shadow_price"><code>InfiniteOpt.map_shadow_price</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_shadow_price(cref::InfOptConstraintRef, key::Val{ext_key_name}; 
                 kwargs...)</code></pre><p>Map the shadow price(s) of <code>cref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default where <code>kwargs</code> are passed on to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL504-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_reduced_cost" href="#InfiniteOpt.map_reduced_cost"><code>InfiniteOpt.map_reduced_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_reduced_cost(vref::GeneralVariableRef, key::Val{ext_key_name}, 
                  result::Int; kwargs...)</code></pre><p>Map the reduced cost(s) of <code>vref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code>. Such as is the case with reformulations  that do not have a direct mapping between variables in the original infinite form. Otherwise, <code>optimizer_model_variable</code>, is used to make these mappings by default where <code>kwargs</code> are passed on these functions. Here  <code>result</code> is the result index used in <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/9ed9f38aacda2cfe3a5c1e8791b7786640c0c21b/src/results.jl#LL259-L271">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimize/">« Optimization</a><a class="docs-footer-nextpage" href="../../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 25 May 2021 20:45">Tuesday 25 May 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
