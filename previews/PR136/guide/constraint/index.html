<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li class="is-active"><a class="tocitem" href>Constraints</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Data-Structure"><span>Data Structure</span></a></li><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#Modification"><span>Modification</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods/Macros"><span>Methods/Macros</span></a></li></ul></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constraints</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/constraint.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="constr_page"><a class="docs-heading-anchor" href="#constr_page">Constraints</a><a id="constr_page-1"></a><a class="docs-heading-anchor-permalink" href="#constr_page" title="Permalink"></a></h1><p>A guide and manual for defining and manipulating constraints in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Constraints are a key part of infinite dimensional problems and serve as a fundamental utility of <code>InfiniteOpt</code>. In particular, <code>InfiniteOpt</code> supports finite constraints that entail finite variables and/or measures that fully remove any infinite parameter dependencies (e.g., first stage constraints), infinite constraints that are enforced over the entire domain of its infinite parameter dependencies (e.g., path constraints), and restricted constraints which are enforced over some specified sub-domain of its infinite parameter dependencies (e.g., boundary conditions). This page will highlight how to implement these types of constraints in <code>InfiniteOpt</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Nonlinear constraints as defined by <code>JuMP.@NLconstraint</code> are not currently  supported by <code>InfiniteOpt</code>. See <a href="../expression/#Nonlinear-Expressions">Nonlinear Expressions</a> for more  information and possible workarounds. </p></div></div><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Principally, the  <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>  macro is used to define constraints. First, let&#39;s setup an infinite model with variables that we can add constraints to:</p><pre><code class="language-julia-repl">julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @infinite_parameter(model, x[1:2] in [-2, 2]);

julia&gt; @variable(model, ya, Infinite(t, x));

julia&gt; @variable(model, yb, Infinite(t));

julia&gt; @variable(model, z[1:2]);</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike previous versions, <code>InfiniteOpt</code> now supports all of the constraints  offered by <code>JuMP</code>, including vector and semi-definite constraints! Please  see <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/constraints/#Constraints">JuMP&#39;s constraint documentation</a>  for a thorough explanation of the supported types and syntax.</p></div></div><h3 id="Scalar-Constraints"><a class="docs-heading-anchor" href="#Scalar-Constraints">Scalar Constraints</a><a id="Scalar-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Constraints" title="Permalink"></a></h3><p>Scalar constraints use scalar functions of variables. For example, let&#39;s define  the constraint  <span>$||z||^2 + 2y_a(t, x) \leq 0, \ \forall t \in [0, 10], x \in [-2, 2]^2$</span>  using <code>@constraint</code>:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, c1, sum(z[i]^2 for i = 1:2) + 2ya &lt;= 0)
c1 : z[1]² + z[2]² + 2 ya(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ∈ [-2, 2], x[2] ∈ [-2, 2]</code></pre><p>Thus, we added an infinite constraint (which infinite with respect to <code>t</code> and <code>x</code>) to <code>model</code> and stored the corresponding constraint reference to <code>c1</code>. Note that  this is enforced over the full infinite domains of the infinite parameters <code>t</code>  and <code>x</code> which are implicitly used by <code>c1</code>. For scalar constraints like this one,  the allowed constraint operators are <code>==</code>, <code>&lt;=</code>, <code>≤</code>, <code>&gt;=</code>, and <code>≥</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Linear algebra constraints can also be used when defining constraints when <code>.</code> is added in front of the constraint operators (e.g., <code>.&lt;=</code>). This behavior is further explained in  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/constraints/#Vectorized-constraints"><code>JuMP</code>&#39;s constraint documentation</a>. </p></div></div><p>Similarly, we can define an array of constraints with varied indexes by including an additional argument before the constraint expression. For example, let&#39;s define <span>$3z_i - 14 = 0, \ \forall i \in \{1,2\}$</span>:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, c2[i = 1:2], 3z[i] - 14 == 0)
2-element Array{InfOptConstraintRef,1}:
 c2[1] : 3 z[1] = 14.0
 c2[2] : 3 z[2] = 14.0</code></pre><p>Thus, we added two constraints to <code>model</code> and stored a vector of the corresponding constraint references to the <code>Julia</code> variable <code>c2</code>. To learn more about building  containers of constraints please see  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/constraints/#Constraint-containers"><code>JuMP</code>&#39;s constraint container documentation</a>.</p><h3 id="Multi-Dimensional-Constraints"><a class="docs-heading-anchor" href="#Multi-Dimensional-Constraints">Multi-Dimensional Constraints</a><a id="Multi-Dimensional-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Dimensional-Constraints" title="Permalink"></a></h3><p>Building upon <code>JuMP</code> we support a variety of multi-dimensional constraint types.  For example, we can define the vector constraint:</p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = [5, 6]
2-element Array{Int64,1}:
 5
 6

julia&gt; @constraint(model, A * z - b in MOI.Nonnegatives(2))
[z[1] + 2 z[2] - 5, 3 z[1] + 4 z[2] - 6] ∈ MathOptInterface.Nonnegatives(2)</code></pre><p>See <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/constraints/"><code>JuMP</code>&#39;s constraint documentation</a>  for a thorough tutorial on the accepted syntax and constraint types.</p><h3 id="Restricted-Constraints"><a class="docs-heading-anchor" href="#Restricted-Constraints">Restricted Constraints</a><a id="Restricted-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Restricted-Constraints" title="Permalink"></a></h3><p>Restricted constraints entail an infinite domain (determined by the infinite  parameters they explicitly/implicitly depend on) that is restricted to a certain  sub-domain. Such constraints are common for enforcing initial/boundary conditions  and for enforcing path constraints over a certain sub-domain.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Previous versions of <code>InfiniteOpt</code> referred to restricted constraints as  &quot;bounded constraints&quot; and used <code>@BDconstraint</code> to define them. This has been  deprecated in favor of the more intuitive domain restricted nomenclature.</p><pre><code class="language-julia"># Old syntax
@BDconstraint(model, name_expr(restricts...), constr_expr)

# New syntax
@constraint(model, name_expr, constr_expr, DomainRestrictions(restricts...))</code></pre></div></div><p>These types of constraints are defined adding <a href="#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a>. For  example, let&#39;s add the initial condition <span>$y_b(0) = 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, initial, yb == 0, DomainRestrictions(t =&gt; 0))
initial : yb(t) = 0.0, ∀ t = 0</code></pre><p>Thus, we have added a constraint to <code>model</code> defined over the sub-domain <span>$t = 0$</span> in accordance with the initial condition.</p><p>More complex sub-domains can be specified by simply adding more restrictions. To  illustrate this, let&#39;s define the constraint  <span>$2y_b^2(t, x) + z_1 \geq 3, \ \forall t = 0, \ x \in [-1, 1]^2$</span>:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, 2ya^2 + z[1] &gt;= 3, DomainRestrictions(t =&gt; 0, x =&gt; [-1, 1]))
2 ya(t, x)² + z[1] ≥ 3.0, ∀ t = 0, x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]</code></pre><p>Now we have added constraints to our model and it is ready to be solved!</p><h2 id="Data-Structure"><a class="docs-heading-anchor" href="#Data-Structure">Data Structure</a><a id="Data-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structure" title="Permalink"></a></h2><p>Here we detail the data structures used to store constraints in <code>InfiniteOpt</code>. In general, constraints in <code>JuMP</code> are of the form: <code>function in set</code> where <code>function</code> corresponds to a <code>JuMP</code> expression and <code>set</code> corresponds to a <code>MOI</code> set. This leads to the following data structures:</p><table><tr><th style="text-align: center">Constraint Type</th><th style="text-align: center">Function Type</th><th style="text-align: center">Set Type</th></tr><tr><td style="text-align: center">Scalar</td><td style="text-align: center"><code>JuMP.AbstractJuMPScalar</code></td><td style="text-align: center"><a href="https://jump.dev/MathOptInterface.jl/v0.9.22/reference/standard_form/#MathOptInterface.AbstractScalarSet"><code>MOI.AbstractScalarSet</code></a></td></tr><tr><td style="text-align: center">Vector</td><td style="text-align: center"><code>Vector{&lt;:JuMP.AbstractJuMPScalar}</code></td><td style="text-align: center"><a href="https://jump.dev/MathOptInterface.jl/v0.9.22/reference/standard_form/#MathOptInterface.AbstractVectorSet"><code>MOI.AbstractVectorSet</code></a></td></tr><tr><td style="text-align: center">Matrix</td><td style="text-align: center"><code>Matrix{&lt;:JuMP.AbstractJuMPScalar}</code></td><td style="text-align: center"><code>MOI.AbstractVectorSet</code> <a href="https://jump.dev/MathOptInterface.jl/v0.9.22/reference/standard_form/#Matrix-sets">via vectorization</a></td></tr></table><p>The above combos are then stored in  <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/constraints/#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a>s  and <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/constraints/#JuMP.VectorConstraint">`JuMP.VectorConstraint</a>s. </p><p>Restricted constraints are built upon this data structure where the underlying  constraint is created in the same manner. Then the specified  <a href="#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> are added by creating a  <a href="#InfiniteOpt.DomainRestrictedConstraint"><code>DomainRestrictedConstraint</code></a> which stores the <code>JuMP.AbstractConstraint</code>  and the restrictions.</p><p>These constraint objects are what store constraints in <code>InfiniteModel</code>s. And these are pointed to by <a href="#InfiniteOpt.InfOptConstraintRef"><code>InfOptConstraintRef</code></a>s.</p><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><p>In this section, we describe the ins and outs of defining constraints. Note that this process is analogous to the manner in which variables are defined and added to the model.</p><h3 id="Manual-Definition"><a class="docs-heading-anchor" href="#Manual-Definition">Manual Definition</a><a id="Manual-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Definition" title="Permalink"></a></h3><p>Defining a constraint principally involves the following steps:</p><ul><li>Define the constraint information (i.e., function, set, and domain restrictions)</li><li>Construct a concrete subtype of <code>JuMP.AbstractConstraint</code> to store the  constraint information</li><li>Add the <code>AbstractConstraint</code> object to an <code>InfiniteModel</code> and assign a name</li><li>Create an <a href="#InfiniteOpt.InfOptConstraintRef"><code>InfOptConstraintRef</code></a> that points to the constraint object  stored in the model.</li></ul><p>The constraint objects are specified via <code>JuMP.build_constraint</code> which requires  that the user provides a function, set, and optionally include domain  restrictions. For example, let&#39;s build a scalar constraint  <span>$3y_a(t, x) - y_b^2(t) \leq 0, \ \forall t \in [0, 10], x \in [-2, 2]^2$</span> over  its full infinite domain (i.e., have no <code>DomainRestrictions</code>):</p><pre><code class="language-julia-repl">julia&gt; constr = build_constraint(error, 3ya - yb^2, MOI.LessThan(0.0));</code></pre><p>Now the built constraint object can be added to the infinite model via <a href="#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint,String}"><code>add_constraint</code></a>. Let&#39;s do so with our example and assign it the name of  <code>c3</code> (note that adding a name is optional):</p><pre><code class="language-julia-repl">julia&gt; cref = add_constraint(model, constr, &quot;c3&quot;)
c3 : -yb(t)² + 3 ya(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ∈ [-2, 2], x[2] ∈ [-2, 2]</code></pre><p>Thus, we have made our constraint and added it <code>model</code> and now have a constraint reference <code>cref</code> that we can use to access it.</p><p>The <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>  and <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/constraints/#JuMP.@SDconstraint"><code>@SDconstraint</code></a>  macros automate the above steps.</p><h3 id="Macro-Definition"><a class="docs-heading-anchor" href="#Macro-Definition">Macro Definition</a><a id="Macro-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-Definition" title="Permalink"></a></h3><p>As mentioned above in the Basic Usage section, the  <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>  macro should be used to define constraints with the syntax:  <code>@constraint(model::InfiniteModel, [container/name_expr], constr_expr, [rs::DomainRestrictions])</code>.</p><p>The second argument is optional and is used to assign a name and/or define indexing variables to be used in the constraint expr. When a name is provided it is registered and cannot be used again for another constraint or variable name. The indexing expression can be used to produce an array of constraints as shown below (notice this is equivalent to looping over individual <code>@constraint</code> calls):</p><pre><code class="language-julia-repl">julia&gt; crefs = @constraint(model, [i = 1:2], 2z[i] - yb == 0)
2-element Array{InfOptConstraintRef,1}:
 2 z[1] - yb(t) = 0.0, ∀ t ∈ [0, 10]
 2 z[2] - yb(t) = 0.0, ∀ t ∈ [0, 10]

julia&gt; crefs = Vector{InfOptConstraintRef}(undef, 2);

julia&gt; for i = 1:2
           crefs[i] = @constraint(model, 2z[i] - yb == 0)
       end

julia&gt; crefs
2-element Array{InfOptConstraintRef,1}:
 2 z[1] - yb(t) = 0.0, ∀ t ∈ [0, 10]
 2 z[2] - yb(t) = 0.0, ∀ t ∈ [0, 10]</code></pre><p>Please refer to  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/constraints/#Constraint-containers"><code>JuMP</code>&#39;s constraint container documentation</a>  for a thorough tutorial on creating containers of constraints.</p><p>Any constraint type supported by <code>JuMP</code> can be specified in the <code>constr_expr</code>  argument. This includes a wealth of constraint types including:</p><ul><li>Variable constraints</li><li>Scalar constraints</li><li>Vector constraints</li><li>Conic constraints </li><li>Indicator constraints</li><li>Semi-definite constraints</li></ul><p>For example, we could define the following semi-definite constraint using  <code>@SDconstraint</code>:</p><pre><code class="language-julia-repl">julia&gt; @SDconstraint(model, [yb 2yb; 3yb 4yb] &gt;= ones(2, 2))
[yb(t) - 1    2 yb(t) - 1;
 3 yb(t) - 1  4 yb(t) - 1] ∈ PSDCone(), ∀ t ∈ [0, 10]</code></pre><p>See <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/constraints/"><code>JuMP</code>&#39;s constraint documentation</a>  for a thorough tutorial on the accepted syntax and constraint types.</p><p>Finally, restrictions on the inherent infinite domain of a constraint can be  specified via <a href="#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> with the <code>rs</code> argument. The accepted  syntax is <code>DomainRestrictions(restricts...)</code> where each argument of <code>restricts</code>  can be any of the following forms:</p><ul><li><code>pref =&gt; value</code></li><li><code>pref =&gt; [lb, ub]</code></li><li><code>pref =&gt; IntervalDomain(lb, ub)</code></li><li><code>prefs =&gt; value</code></li><li><code>prefs =&gt; [lb, ub]</code></li><li><code>prefs =&gt; IntervalDomain(lb, ub)</code>.</li></ul><p>Note that <code>pref</code> and <code>prefs</code> must correspond to infinite parameters.</p><p>For example, we can define the constraint <span>$y_a^2(t, x) + z_i \leq 1$</span> and  restrict the infinite domain of <span>$x_i$</span> to be <span>$[0, 1]$</span>:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, [i = 1:2], ya^2 + z[i] &lt;= 1, DomainRestrictions(x[i] =&gt; [0, 1]))
2-element Array{InfOptConstraintRef,1}:
 ya(t, x)² + z[1] ≤ 1.0, ∀ t ∈ [0, 10], x[1] ∈ [0, 1], x[2] ∈ [-2, 2]
 ya(t, x)² + z[2] ≤ 1.0, ∀ t ∈ [0, 10], x[1] ∈ [-2, 2], x[2] ∈ [0, 1]</code></pre><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><p>In this section, we describe a variety of methods to extract constraint information.</p><h3 id="Basic"><a class="docs-heading-anchor" href="#Basic">Basic</a><a id="Basic-1"></a><a class="docs-heading-anchor-permalink" href="#Basic" title="Permalink"></a></h3><p>A number of constraint properties can be extracted via constraint references. Principally, the validity, name, model, index, and constraint object can be queried via <a href="#JuMP.is_valid-Tuple{InfiniteModel,InfOptConstraintRef}"><code>is_valid</code></a>, <a href="#JuMP.name-Tuple{InfOptConstraintRef}"><code>name</code></a>, <a href="#JuMP.owner_model-Tuple{InfOptConstraintRef}"><code>owner_model</code></a>, <a href="#JuMP.index-Tuple{InfOptConstraintRef}"><code>index</code></a>, and <a href="#JuMP.constraint_object-Tuple{InfOptConstraintRef}"><code>constraint_object</code></a>, respectively. These methods all constitute  extensions of <code>JuMP</code> methods and follow exactly the same behavior. Let&#39;s try  them out with the following example:</p><pre><code class="language-julia-repl">julia&gt; is_valid(model, c1) # check if contained in model
true

julia&gt; name(c1) # get the name
&quot;c1&quot;

julia&gt; m = owner_model(c1); # get the model it is added to

julia&gt; index(c1) # get the constraint&#39;s index
InfOptConstraintIndex(1)

julia&gt; constr = constraint_object(c1); # get the raw constraint datatype</code></pre><p>Also, <a href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>constraint_by_name</code></a> can be used to retrieve a constraint reference  if only the name is known and its name is unique. For example, let&#39;s extract the  reference for <code>&quot;c1&quot;</code>:</p><pre><code class="language-julia-repl">julia&gt; cref = constraint_by_name(model, &quot;c1&quot;)
c1 : z[1]² + z[2]² + 2 ya(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ∈ [-2, 2], x[2] ∈ [-2, 2]</code></pre><h3 id="Domain-Restrictions"><a class="docs-heading-anchor" href="#Domain-Restrictions">Domain Restrictions</a><a id="Domain-Restrictions-1"></a><a class="docs-heading-anchor-permalink" href="#Domain-Restrictions" title="Permalink"></a></h3><p>As explained above, restricted constraints serve as a key capability of <code>InfiniteOpt</code>. Information about domain restrictions can be obtained via <a href="#InfiniteOpt.has_domain_restrictions"><code>has_domain_restrictions</code></a> and <a href="#InfiniteOpt.domain_restrictions"><code>domain_restrictions</code></a> which indicate if a constraint is restricted and what its <a href="#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> are, respectively. These are exemplified below:</p><pre><code class="language-julia-repl">julia&gt; has_domain_restrictions(c1) # check if constraint is bounded
false

julia&gt; has_domain_restrictions(initial)
true

julia&gt; domain_restrictions(initial)
Subdomain restrictions (1): t = 0</code></pre><h3 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h3><p>Constraints can be defined in a number of ways symbolically that differ from how it is actually stored in the model. This principally occurs since like terms and constants are combined together where possible with the variable terms on the left hand side and the constant on the right hand side. For instance, the constraint <span>$2y_b(t) + 3y_b(t) - 2 \leq 1 + z_1$</span> would be normalized  <span>$5y_b(t) - z_1 \leq 3$</span>. In accordance with this behavior,  <a href="#JuMP.normalized_rhs-Tuple{InfOptConstraintRef}"><code>normalized_rhs</code></a> and <a href="#JuMP.normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef}"><code>normalized_coefficient</code></a> can be used to query the normalized right hand side and the coefficient of a particular variable reference, respectively. Let&#39;s employ the above example to illustrate this:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, constr, 2yb + 3yb - 2 &lt;= 1 + z[1])
constr : 5 yb(t) - z[1] ≤ 3.0, ∀ t ∈ [0, 10]

julia&gt; normalized_rhs(constr)
3.0

julia&gt; normalized_coefficient(constr, yb)
5.0</code></pre><p>There also exist a number of methods for querying an infinite model about what constraints it contains. <a href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>list_of_constraint_types</code></a> can be used query what types of constraints  have been added to a model. This is provided as a list of tuples where the first  element is the expression type and the second element is the set type (recall  that constraints are stored in the form <code>func-in-set</code>). Thus, for our current  model we obtain:</p><pre><code class="language-julia-repl">julia&gt; list_of_constraint_types(model)
4-element Array{Tuple{DataType,DataType},1}:
 (GenericQuadExpr{Float64,GeneralVariableRef}, MathOptInterface.LessThan{Float64})
 (GenericQuadExpr{Float64,GeneralVariableRef}, MathOptInterface.GreaterThan{Float64})
 (GenericAffExpr{Float64,GeneralVariableRef}, MathOptInterface.LessThan{Float64})
 (GenericAffExpr{Float64,GeneralVariableRef}, MathOptInterface.EqualTo{Float64})</code></pre><p>This information is useful when used in combination with the <a href="#JuMP.num_constraints-Tuple{InfiniteModel,Any,Any}"><code>num_constraints</code></a> and <a href="#JuMP.all_constraints-Tuple{InfiniteModel,Any,Any}"><code>all_constraints</code></a> methods which can take  the expression type and/or the set type as inputs. Here <code>num_constraints</code>  provides the number of constraints that match a certain type  and <code>all_constraints</code>  returns a list of constraint references matching the criteria provided. These have  been extended beyond <code>JuMP</code> functionality such additional methods have been  provided for the cases in which one wants to query solely off of set or off  expression type. Let&#39;s illustrate this with <code>num_constraints</code>:</p><pre><code class="language-julia-repl">julia&gt; num_constraints(model) # total number of constraints
15

julia&gt; num_constraints(model, GenericQuadExpr{Float64,GeneralVariableRef})
5

julia&gt; num_constraints(model, MOI.LessThan{Float64})
5

julia&gt; num_constraints(model, GenericQuadExpr{Float64,GeneralVariableRef},
                       MOI.LessThan{Float64})
4                   </code></pre><h2 id="Modification"><a class="docs-heading-anchor" href="#Modification">Modification</a><a id="Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Modification" title="Permalink"></a></h2><p>In this section, we highlight a number of methods that can be used to modify existing constraints.</p><h3 id="Deletion"><a class="docs-heading-anchor" href="#Deletion">Deletion</a><a id="Deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Deletion" title="Permalink"></a></h3><p>All constraints in <code>InfiniteOpt</code> can be removed in like manner to typical <code>JuMP</code> constraints with the appropriate extension of <a href="#JuMP.delete-Tuple{InfiniteModel,InfOptConstraintRef}"><code>delete</code></a>. This will remove the corresponding constraint object from the model. However, please note any registered names will remain registered in the infinite model. This means that a constraint with a registered name cannot be repeatedly added and removed using the same name. To exemplify this, let&#39;s delete the constraint <code>c1</code>:</p><pre><code class="language-julia-repl">julia&gt; delete(model, c1)</code></pre><h3 id="General-2"><a class="docs-heading-anchor" href="#General-2">General</a><a class="docs-heading-anchor-permalink" href="#General-2" title="Permalink"></a></h3><p>There also are a number of ways to modify information and characteristics of constraints. First, <a href="#JuMP.set_name-Tuple{InfOptConstraintRef,String}"><code>set_name</code></a> can be used to specify a new name for a particular constraint. For instance, let&#39;s update the name of <code>initial</code> to <code>&quot;init_cond&quot;</code>:</p><pre><code class="language-julia-repl">julia&gt; set_name(initial, &quot;init_cond&quot;)

julia&gt; initial
init_cond : yb(t) = 0.0, ∀ t = 0</code></pre><p>We can also update the normalized right hand side constant value or normalized left hand side variable coefficient value using <a href="#JuMP.set_normalized_rhs-Tuple{InfOptConstraintRef,Real}"><code>set_normalized_rhs</code></a> and <a href="#JuMP.set_normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef,Real}"><code>set_normalized_coefficient</code></a>,  respectively. Let&#39;s again consider the constraint <span>$5y_b(t) - z_1 \leq 3$</span> as an example. Let&#39;s change the constant term to -1 and the <code>y_b(t)</code> coefficient to 2.5:</p><pre><code class="language-julia-repl">julia&gt; set_normalized_rhs(constr, -1)

julia&gt; set_normalized_coefficient(constr, yb, 2.5)

julia&gt; constr
constr : 2.5 yb(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 10]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In some cases, it may be more convenient to dynamically modify coefficients and other values via the use of finite parameters. This provides an avenue to update parameters without having to be concerned about the normalized form. For more information, see the <a href="../finite_parameter/#finite_param_docs">Finite Parameters</a> page.</p></div></div><h3 id="Domain-Restrictions-2"><a class="docs-heading-anchor" href="#Domain-Restrictions-2">Domain Restrictions</a><a class="docs-heading-anchor-permalink" href="#Domain-Restrictions-2" title="Permalink"></a></h3><p>Domain Restrictions can be added to, modified, or removed from any constraint in <code>InfiniteOpt</code>. Principally, this is accomplished via  <a href="#InfiniteOpt.add_domain_restrictions"><code>add_domain_restrictions</code></a>, <a href="#InfiniteOpt.set_domain_restrictions"><code>set_domain_restrictions</code></a>, and <a href="#InfiniteOpt.delete_domain_restrictions"><code>delete_domain_restrictions</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Previous versions of <code>InfiniteOpt</code> used <code>@[set/add]_parameter_bounds</code> which  have been deprecated in favor of using <a href="#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> with the  the methods described used in this section.</p></div></div><p>First, domain restrictions can be added to a constraint via  <a href="#InfiniteOpt.add_domain_restrictions"><code>add_domain_restrictions</code></a>. For example, let&#39;s add the bound  <span>$t \in [0, 1]$</span> to <code>constr</code>:</p><pre><code class="language-julia-repl">julia&gt; add_domain_restrictions(constr, DomainRestrictions(t =&gt; [0, 1]))

julia&gt; constr
constr : 2.5 yb(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 1]</code></pre><p>In similar manner, <a href="#InfiniteOpt.set_domain_restrictions"><code>set_domain_restrictions</code></a> can be employed to specify what restrictions a constraint has (overwriting any existing ones if forced). It  follows the same syntax, so let&#39;s use it to change the bounds on <code>t</code> to <span>$t = 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; set_domain_restrictions(constr, DomainRestrictions(t =&gt; 0), force = true)

julia&gt; constr
constr : 2.5 yb(t) - z[1] ≤ -1.0, ∀ t = 0</code></pre><p>Finally, constraint restrictions can be deleted via <a href="#InfiniteOpt.delete_domain_restrictions"><code>delete_domain_restrictions</code></a>. Now let&#39;s delete the domain restrictions  associated with our example:</p><pre><code class="language-julia-repl">julia&gt; delete_domain_restrictions(constr)

julia&gt; constr
constr : 2.5 yb(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 10]</code></pre><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.ConstraintData"><code>InfiniteOpt.ConstraintData</code></a></li><li><a href="#InfiniteOpt.DomainRestrictedConstraint"><code>InfiniteOpt.DomainRestrictedConstraint</code></a></li><li><a href="#InfiniteOpt.DomainRestrictions"><code>InfiniteOpt.DomainRestrictions</code></a></li><li><a href="#InfiniteOpt.InfOptConstraintIndex"><code>InfiniteOpt.InfOptConstraintIndex</code></a></li><li><a href="#InfiniteOpt.InfOptConstraintRef"><code>InfiniteOpt.InfOptConstraintRef</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DomainRestrictions" href="#InfiniteOpt.DomainRestrictions"><code>InfiniteOpt.DomainRestrictions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DomainRestrictions{P &lt;: GeneralVariableRef}</code></pre><p>A <code>DataType</code> for storing interval domains that constrain particular infinite  parameters to a subdomain relative to their full domain. This is used to define subdomains of <a href="#InfiniteOpt.DomainRestrictedConstraint"><code>DomainRestrictedConstraint</code></a>s. Note that the GeneralVariableRef must pertain to infinite parameters.</p><p>The constructor syntax is</p><pre><code class="language-julia">DomainRestrictions(restrictions...)</code></pre><p>where each argument of <code>restrictions</code> is one of the following forms:</p><ul><li><code>pref =&gt; value</code></li><li><code>pref =&gt; [lb, ub]</code></li><li><code>pref =&gt; IntervalDomain(lb, ub)</code></li><li><code>prefs =&gt; value</code></li><li><code>prefs =&gt; [lb, ub]</code></li><li><code>prefs =&gt; IntervalDomain(lb, ub)</code>.</li></ul><p>Note that <code>pref</code> and <code>prefs</code> must correspond to infinite parameters. </p><p><strong>Fields</strong></p><ul><li><code>intervals::Dict{GeneralVariableRef, IntervalDomain}</code>: A dictionary of interval bounds on infinite parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/datatypes.jl#LL643-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DomainRestrictedConstraint" href="#InfiniteOpt.DomainRestrictedConstraint"><code>InfiniteOpt.DomainRestrictedConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DomainRestrictedConstraint{C &lt;: JuMP.AbstractConstraint, 
                           P &lt;: GeneralVariableRef
                           } &lt;: JuMP.AbstractConstraint</code></pre><p>A <code>DataType</code> for creating a constraint with enforced <code>DomainRestrictions</code>. For  example this may pertain to a boundary condition.</p><p><strong>Fields</strong></p><ul><li><code>constraint::C</code>: The optimization constraint.</li><li><code>restrictions::DomainRestrictions{P}</code>: The restrictions that determine the   sub-domain of the constraint.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/datatypes.jl#LL1121-L1133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ConstraintData" href="#InfiniteOpt.ConstraintData"><code>InfiniteOpt.ConstraintData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstraintData{C &lt;: JuMP.AbstractConstraint} &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing constraints and their data.</p><p><strong>Fields</strong></p><ul><li><code>constraint::C</code>: The constraint.</li><li><code>object_nums::Vector{Int}</code>: The object numbers of the parameter objects that the                             constraint depends on.</li><li><code>name::String</code>: The name used for printing.</li><li><code>measure_indices::Vector{MeasureIndex}</code>: Indices of dependent measures.</li><li><code>is_info_constraint::Bool</code>: Is this is constraint based on variable info   (e.g., lower bound)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/datatypes.jl#LL1141-L1154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptConstraintIndex" href="#InfiniteOpt.InfOptConstraintIndex"><code>InfiniteOpt.InfOptConstraintIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><p>InOptConstraintIndex &lt;: ObjectIndex</p><p>A <code>DataType</code> for storing the index of a constraint.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/datatypes.jl#LL160-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptConstraintRef" href="#InfiniteOpt.InfOptConstraintRef"><code>InfiniteOpt.InfOptConstraintRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfOptConstraintRef</code></pre><p>A <code>DataType</code> for constraints that are in <code>InfiniteModel</code>s</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::InfOptConstraintIndex</code>: Index of the constraint in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/datatypes.jl#LL1642-L1650">source</a></section></article><h2 id="Methods/Macros"><a class="docs-heading-anchor" href="#Methods/Macros">Methods/Macros</a><a id="Methods/Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Methods/Macros" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.add_domain_restrictions"><code>InfiniteOpt.add_domain_restrictions</code></a></li><li><a href="#InfiniteOpt.delete_domain_restrictions"><code>InfiniteOpt.delete_domain_restrictions</code></a></li><li><a href="#InfiniteOpt.domain_restrictions"><code>InfiniteOpt.domain_restrictions</code></a></li><li><a href="#InfiniteOpt.has_domain_restrictions"><code>InfiniteOpt.has_domain_restrictions</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{InfOptConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.set_domain_restrictions"><code>InfiniteOpt.set_domain_restrictions</code></a></li><li><a href="#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint,String}"><code>JuMP.add_constraint</code></a></li><li><a href="#JuMP.add_to_function_constant-Tuple{InfOptConstraintRef,Real}"><code>JuMP.add_to_function_constant</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel,Any,Any}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.build_constraint-Tuple{Function,Any,Any,DomainRestrictions}"><code>JuMP.build_constraint</code></a></li><li><a href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>JuMP.constraint_by_name</code></a></li><li><a href="#JuMP.constraint_object-Tuple{InfOptConstraintRef}"><code>JuMP.constraint_object</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,InfOptConstraintRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.index-Tuple{InfOptConstraintRef}"><code>JuMP.index</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,InfOptConstraintRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>JuMP.list_of_constraint_types</code></a></li><li><a href="#JuMP.name-Tuple{InfOptConstraintRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef}"><code>JuMP.normalized_coefficient</code></a></li><li><a href="#JuMP.normalized_rhs-Tuple{InfOptConstraintRef}"><code>JuMP.normalized_rhs</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel,Any,Any}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.owner_model-Tuple{InfOptConstraintRef}"><code>JuMP.owner_model</code></a></li><li><a href="#JuMP.set_name-Tuple{InfOptConstraintRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef,Real}"><code>JuMP.set_normalized_coefficient</code></a></li><li><a href="#JuMP.set_normalized_rhs-Tuple{InfOptConstraintRef,Real}"><code>JuMP.set_normalized_rhs</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_constraint-Tuple{Function,Any,Any,DomainRestrictions}" href="#JuMP.build_constraint-Tuple{Function,Any,Any,DomainRestrictions}"><code>JuMP.build_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_constraint(_error::Function, func, set,
                      restrictions::DomainRestrictions{GeneralVariableRef}
                      )::DomainRestrictedConstraint</code></pre><p>Extend <code>JuMP.buid_constraint</code> to handle including <code>restrictions</code> to its inherit  infinite parameter domains in addition to the traditional <code>func</code> in <code>set</code> setup.  This returns a <code>DomainRestrictedConstraint</code> that can then  be added via <code>JuMP.add_constraint</code>. Errors if the restrictions are incompadible  with infinite parameter domains. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; restrictions = DomainRestrictions(t =&gt; 0)
Subdomain restrictions (1): t = 0

julia&gt; con = build_constraint(error, y + 2, MOI.LessThan(0.0), restrictions);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL186-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint,String}" href="#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint,String}"><code>JuMP.add_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_constraint(model::InfiniteModel, c::JuMP.AbstractConstraint,
                    [name::String = &quot;&quot;])::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.add_constraint</code> to add a constraint <code>c</code> to an infinite model <code>model</code> with name <code>name</code>. Returns an appropriate constraint reference whose type depends on what variables are used to define the constraint. Errors if any  variables do not belong to <code>model</code>. This is primarily used as an internal method for the constraint macros.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @variable(model, g, Infinite(t));

julia&gt; @variable(model, x);

julia&gt; constr = build_constraint(error, g + x, MOI.EqualTo(42));

julia&gt; cref = add_constraint(model, constr, &quot;name&quot;)
name : g(t) + x = 42.0, ∀ t ∈ [0, 10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL266-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.owner_model-Tuple{InfOptConstraintRef}" href="#JuMP.owner_model-Tuple{InfOptConstraintRef}"><code>JuMP.owner_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.owner_model(cref::InfOptConstraintRef)::InfiniteModel</code></pre><p>Extend <code>JuMP.owner_model</code> to return the infinite model associated with <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; model = owner_model(cref)
An InfiniteOpt Model
Minimization problem with:
Finite Parameters: 0
Infinite Parameters: 3
Variables: 3
Derivatives: 0
Measures: 0
Objective function type: GeneralVariableRef
`GenericAffExpr{Float64,GeneralVariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
Names registered in the model: g, t, h, x
Optimizer model backend information:
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL4-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.index-Tuple{InfOptConstraintRef}" href="#JuMP.index-Tuple{InfOptConstraintRef}"><code>JuMP.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.index(cref::InfOptConstraintRef)::InfOptConstraintIndex</code></pre><p>Extend <code>JuMP.index</code> to return the index of an <code>InfiniteOpt</code> constraint <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; index(cref)
InfOptConstraintIndex(2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.constraint_object-Tuple{InfOptConstraintRef}" href="#JuMP.constraint_object-Tuple{InfOptConstraintRef}"><code>JuMP.constraint_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.constraint_object(cref::InfOptConstraintRef)::JuMP.AbstractConstraint</code></pre><p>Extend <code>JuMP.constraint_object</code> to return the constraint object associated with  <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @variable(model, x &lt;= 1);

julia&gt; cref = UpperBoundRef(x);

julia&gt; obj = constraint_object(cref)
ScalarConstraint{GeneralVariableRef,MathOptInterface.LessThan{Float64}}(x,
MathOptInterface.LessThan{Float64}(1.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL357-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{InfOptConstraintRef}" href="#JuMP.name-Tuple{InfOptConstraintRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(cref::InfOptConstraintRef)::String</code></pre><p>Extend <code>JuMP.name</code> to return the name of an <code>InfiniteOpt</code> constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(cref)
&quot;constr_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL382-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{InfOptConstraintRef,String}" href="#JuMP.set_name-Tuple{InfOptConstraintRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(cref::InfOptConstraintRef, name::String)::Nothing</code></pre><p>Extend <code>JuMP.set_name</code> to specify the name of a constraint <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(cref, &quot;new_name&quot;)

julia&gt; name(cref)
&quot;new_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL398-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,InfOptConstraintRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,InfOptConstraintRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, cref::InfOptConstraintRef)::Bool</code></pre><p>Extend <code>JuMP.is_valid</code> to return <code>Bool</code> whether an <code>InfiniteOpt</code> constraint  reference is valid.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_valid(model, cref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL337-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,InfOptConstraintRef}" href="#JuMP.delete-Tuple{InfiniteModel,InfOptConstraintRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, cref::InfOptConstraintRef)::Nothing</code></pre><p>Extend <code>JuMP.delete</code> to delete an <code>InfiniteOpt</code> constraint and all associated  information. Errors if <code>cref</code> is invalid.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]

julia&gt; delete(model, cref)

julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z ≥ 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL949-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{InfOptConstraintRef}" href="#InfiniteOpt.parameter_refs-Tuple{InfOptConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(cref::InfOptConstraintRef)::Tuple</code></pre><p>Return the tuple of infinite parameter references that determine the infinite dependencies of <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(cref)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL759-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_domain_restrictions" href="#InfiniteOpt.has_domain_restrictions"><code>InfiniteOpt.has_domain_restrictions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_domain_restrictions(cref::InfOptConstraintRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>cref</code> is limited to a sub-domain as defined by a <a href="#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_domain_restrictions(cref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL780-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.domain_restrictions" href="#InfiniteOpt.domain_restrictions"><code>InfiniteOpt.domain_restrictions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">domain_restrictions(cref::InfOptConstraintRef)::DomainRestrictions{GeneralVariableRef}</code></pre><p>Return the <a href="#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> object associated with the constraint <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; domain_restrictions(cref)
Subdomain restrictions (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL796-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_domain_restrictions" href="#InfiniteOpt.set_domain_restrictions"><code>InfiniteOpt.set_domain_restrictions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_domain_restrictions(cref::InfOptConstraintRef,
                     restrictions:DomainRestrictions{GeneralVariableRef};
                     [force::Bool = false])::Nothing</code></pre><p>Specify a new <a href="#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> object <code>restrictions</code> for the  constraint <code>cref</code>. Errors if <code>cref</code> already has restrictions and <code>force = false</code>.  Where possible it is recommended to use <a href="#InfiniteOpt.add_domain_restrictions"><code>add_domain_restrictions</code></a> instead.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_domain_restrictions(cref, DomainRestrictions(t =&gt; [0, 2]))

julia&gt; domain_restrictions(cref)
Subdomain restrictions (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL815-L831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_domain_restrictions" href="#InfiniteOpt.add_domain_restrictions"><code>InfiniteOpt.add_domain_restrictions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_domain_restrictions(cref::InfOptConstraintRef,
                     new_restrictions::DomainRestrictions{GeneralVariableRef}
                     )::Nothing</code></pre><p>Add additional domain restrictions to <code>cref</code> such that it is defined over the sub-domain based on <code>pref</code> from <code>lower</code> to <code>upper</code>.</p><pre><code class="language-julia-repl">julia&gt; add_domain_restrictions(cref, DomainRestrictions(t =&gt; [0, 2]))

julia&gt; domain_restrictions(cref)
Subdomain restrictions (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL885-L899">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_domain_restrictions" href="#InfiniteOpt.delete_domain_restrictions"><code>InfiniteOpt.delete_domain_restrictions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete_domain_restrictions(cref::InfOptConstraintRef)::Nothing</code></pre><p>Delete all the domain restrictions of the constraint <code>cref</code>. Note any restrictions that are needed for finite variables inside in <code>cref</code> will be unaffected.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @constraint(model, c1, y &lt;= 42, DomainRestrictions(x =&gt; 0))
c1 : y(x) ≤ 42, ∀ x[1] = 0, x[2] = 0

julia&gt; delete_domain_restrictions(c1)

julia&gt; c1
c1 : y(x) ≤ 42, ∀ x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL919-L935">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_normalized_rhs-Tuple{InfOptConstraintRef,Real}" href="#JuMP.set_normalized_rhs-Tuple{InfOptConstraintRef,Real}"><code>JuMP.set_normalized_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_normalized_rhs(cref::InfOptConstraintRef, value::Real)::Nothing</code></pre><p>Set the right-hand side term of <code>constraint</code> to <code>value</code>. Note that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint <code>2x + 1 &lt;= 2</code>, <code>set_normalized_rhs(con, 4)</code> will create the constraint <code>2x &lt;= 4</code>, not <code>2x + 1 &lt;= 4</code>.</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, con, 2x + 1 &lt;= 2)
con : 2 x ≤ 1.0

julia&gt; set_normalized_rhs(con, 4)

julia&gt; con
con : 2 x ≤ 4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL439-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.normalized_rhs-Tuple{InfOptConstraintRef}" href="#JuMP.normalized_rhs-Tuple{InfOptConstraintRef}"><code>JuMP.normalized_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.normalized_rhs(cref::InfOptConstraintRef)::Float64</code></pre><p>Return the right-hand side term of <code>cref</code> after JuMP has converted the constraint into its normalized form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL470-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_to_function_constant-Tuple{InfOptConstraintRef,Real}" href="#JuMP.add_to_function_constant-Tuple{InfOptConstraintRef,Real}"><code>JuMP.add_to_function_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_to_function_constant(cref::InfOptConstraintRef, value::Real)::Nothing</code></pre><p>Add <code>value</code> to the function constant term. Note that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by <code>-value</code>. For example, given a constraint <code>2x &lt;= 3</code>, <code>add_to_function_constant(c, 4)</code> will modify it to <code>2x &lt;= -1</code>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL483-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef,Real}" href="#JuMP.set_normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef,Real}"><code>JuMP.set_normalized_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_normalized_coefficient(cref::InfOptConstraintRef,
                                variable::GeneralVariableRef,
                                value::Real)::Nothing</code></pre><p>Set the coefficient of <code>variable</code> in the constraint <code>constraint</code> to <code>value</code>. Note that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint <code>2x + 3x &lt;= 2</code>, <code>set_normalized_coefficient(con, x, 4)</code> will create the constraint <code>4x &lt;= 2</code>.</p><pre><code class="language-julia-repl">julia&gt; con
con : 5 x ≤ 2.0

julia&gt; set_normalized_coefficient(con, x, 4)

julia&gt; con
con : 4 x ≤ 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL502-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef}" href="#JuMP.normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef}"><code>JuMP.normalized_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.normalized_coefficient(cref::InfOptConstraintRef,
                            variable::GeneralVariableRef)::Float64</code></pre><p>Return the coefficient associated with <code>variable</code> in <code>constraint</code> after JuMP has normalized the constraint into its standard form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL536-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.constraint_by_name-Tuple{InfiniteModel,String}" href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>JuMP.constraint_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.constraint_by_name(model::InfiniteModel,
                        name::String)::Union{InfOptConstraintRef, Nothing}</code></pre><p>Extend <code>JuMP.constraint_by_name</code> to return the constraint reference associated with <code>name</code> if one exists or returns nothing. Errors if more than one constraint uses the same name.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; constraint_by_name(model, &quot;constr_name&quot;)
constr_name : x + pt = 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL559-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.list_of_constraint_types-Tuple{InfiniteModel}" href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>JuMP.list_of_constraint_types</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.list_of_constraint_types(model::InfiniteModel)::Vector{Tuple{DataType, DataType}}</code></pre><p>Extend <code>JuMP.list_of_constraint_types</code> to return a list of tuples that contain  all the used combinations of function types and set types in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; all_constraints(model)
3-element Array{Tuple{DataType,DataType},1}:
 (GeneralVariableRef, MathOptInterface.LessThan{Float64})
 (GeneralVariableRef, MathOptInterface.GreaterThan{Float64})
 (GeneralVariableRef, MathOptInterface.Integer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL730-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel,Any,Any}" href="#JuMP.num_constraints-Tuple{InfiniteModel,Any,Any}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel, [function_type], [set_type])::Int</code></pre><p>Extend <code>JuMP.num_constraints</code> to return the number of constraints with a  partiuclar function type and set type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_constraints(model, FiniteVariableRef, MOI.LessThan)
1

julia&gt; num_constraints(model, FiniteVariableRef)
3

julia&gt; num_constraints(model, MOI.LessThan)
2

julia&gt; num_constraints(model)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL599-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel,Any,Any}" href="#JuMP.all_constraints-Tuple{InfiniteModel,Any,Any}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel, [function_type], [set_type])::Vector{InfOptConstraintRef}</code></pre><p>Extend <code>JuMP.all_constraints</code> to return a list of all the constraints with a  particular function type and set type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; all_constraints(model, GeneralVariableRef, MOI.LessThan)
1-element Array{InfOptConstraintRef,1}:
 x ≤ 1.0

julia&gt; all_constraints(model, GeneralVariableRef)
3-element Array{InfOptConstraintRef,1}:
 x ≥ 0.0
 x ≤ 3.0
 x integer

julia&gt; all_constraints(model, MOI.GreaterThan)
3-element Array{InfOptConstraintRef,1}:
 x ≥ 0.0
 g(t) ≥ 0.0, ∀ t ∈ [0, 6]
 g(0.5) ≥ 0.0

julia&gt; all_constraints(model)
5-element Array{InfOptConstraintRef,1}:
 x ≥ 0.0
 x ≤ 3.0
 x integer
 g(t) ≥ 0.0, ∀ t ∈ [0, 6]
 g(0.5) ≥ 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/a6a7e58da2ff05e686338cc354d8b8a8d6763ee2/src/constraints.jl#LL656-L688">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../objective/">« Objectives</a><a class="docs-footer-nextpage" href="../transcribe/">Model Transcription »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 26 May 2021 00:45">Wednesday 26 May 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
