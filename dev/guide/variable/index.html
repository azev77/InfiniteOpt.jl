<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variables · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li class="is-active"><a class="tocitem" href>Variables</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Variable-Definition-Methodology"><span>Variable Definition Methodology</span></a></li><li><a class="tocitem" href="#Macro-Variable-Definition"><span>Macro Variable Definition</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#Modification"><span>Modification</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#var_methods"><span>Methods/Macros</span></a></li></ul></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Variables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variables</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/variable.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h1><p>A guide and manual for the definition and use of variables in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Decision variables are at the very core of <code>InfiniteOpt</code> as its name alludes to mathematical programs that entail infinite decision spaces (i.e., contain infinite decision variables). Principally, 4 variable types are employed: infinite, semi-infinite, point, and finite. Infinite variables encompass any  decision variable that is parameterized by an infinite parameter(s) (e.g.,  space-time variables and stochastic recourse variables). Semi-infinite variables  denote infinite variables where certain infinite parameters are restricted to  point values. Point variables are infinite variables at a particular point.  Finally, finite variables are decisions that are made irrespective of the  infinite domain (e.g., first stage variables and design variables).</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Infinite, semi-infinite, point, and finite variables are summarized in the  following table:</p><table><tr><th style="text-align: center">Name</th><th style="text-align: center">Variable Type Object</th><th style="text-align: center">Description</th><th style="text-align: center">Example</th></tr><tr><td style="text-align: center">Infinite</td><td style="text-align: center"><a href="#InfiniteOpt.Infinite"><code>Infinite</code></a></td><td style="text-align: center">decision functions</td><td style="text-align: center"><span>$y(t, x, \xi)$</span></td></tr><tr><td style="text-align: center">Semi-Infinite</td><td style="text-align: center"><a href="#InfiniteOpt.SemiInfinite"><code>SemiInfinite</code></a></td><td style="text-align: center">partially evaluated decision functions</td><td style="text-align: center"><span>$y(t_0, x, \xi)$</span></td></tr><tr><td style="text-align: center">Point</td><td style="text-align: center"><a href="#InfiniteOpt.Point"><code>Point</code></a></td><td style="text-align: center">fully evaluated decision functions</td><td style="text-align: center"><span>$y(t_0, x_0, \xi_k)$</span></td></tr><tr><td style="text-align: center">Finite</td><td style="text-align: center">NA</td><td style="text-align: center">classical decision variables</td><td style="text-align: center"><span>$z$</span></td></tr></table><p>Infinite, semi-infinite, point, and finite variables are defined via  <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/variables/#JuMP.@variable"><code>@variable</code></a>  (inherited from <code>JuMP</code>) with their respective variable type  object arguments: <a href="#InfiniteOpt.Infinite"><code>Infinite</code></a>, <a href="#InfiniteOpt.SemiInfinite"><code>SemiInfinite</code></a>, and <a href="#InfiniteOpt.Point"><code>Point</code></a>  (finite variables don&#39;t use a variable type object).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The variable nomenclature used by previous versions of <code>InfiniteOpt</code> has  been updated for enhanced clarity and long term longevity. Note that  finite variables were previously called hold variables. Also, the  <code>@infinite_variable</code>, <code>@point_variable</code>, and <code>@hold_variable</code> macros are now  discontinued in favor of using <code>@variable</code> for all decision variable  types.</p></div></div><p>Let&#39;s first setup a simple space-time model with infinite parameters time <code>t</code> and spatial position <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_parameter(model, x[1:2] in [-1, 1], independent = true)
2-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]</code></pre><h3 id="Infinite-Variables"><a class="docs-heading-anchor" href="#Infinite-Variables">Infinite Variables</a><a id="Infinite-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-Variables" title="Permalink"></a></h3><p>Now let&#39;s define a time dependent infinite variable <code>y(t)</code> with a lower bound of 0:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, y &gt;= 0, Infinite(t))
y(t)</code></pre><p>This creates a Julia variable <code>y</code> that points to the decision variable <code>y(t)</code> that is stored in <code>model</code> which is added to include a lower bound of 0. Another useful case is that of defining an array of variables <code>w</code> that depend on both position and time:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, w[i = 1:3], Infinite(t, x), start = [0, 2, 1][i])
3-element Array{GeneralVariableRef,1}:
 w[1](t, x)
 w[2](t, x)
 w[3](t, x)</code></pre><p>Thus we create a Julia array variable <code>w</code> whose elements <code>w[i]</code> point to their respective infinite variables <code>w[i](t, x)</code> stored in <code>model</code>. Note that the <code>i</code> used in the array definition can be used to index attributes assigned to each variable in the array. In this case, we used <code>i</code> to assign different initial guess values for each variable via the <code>start</code> keyword argument.</p><p>Moreover, for infinite variables a function can be given to determine the start values over a range of support points (e.g., a guess trajectory). This is discussed further below in the Macro Definition section.</p><h3 id="Semi-Infinite-Variables"><a class="docs-heading-anchor" href="#Semi-Infinite-Variables">Semi-Infinite Variables</a><a id="Semi-Infinite-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-Infinite-Variables" title="Permalink"></a></h3><p>Now let&#39;s restrict the above infinite variables <code>w[i](t, x)</code> to a particular  time via semi-infinite variables:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, w0[i = 1:3], SemiInfinite(w[i], 0, x))
3-element Array{GeneralVariableRef,1}:
 w0[1]
 w0[2]
 w0[3]</code></pre><p>Thus we create a Julia array variable <code>w0</code> whose elements <code>w0[i]</code> point to their respective semi-infinite variables <code>w[i](0, x)</code> stored in <code>model</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Semi-infinite variables are provided for enhancing the generality of <code>InfiniteOpt</code>, but typically can be avoided by using infinite variables in combination with adding <a href="../constraint/#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> to constraints which  restrict the infinite domain as needed.</p></div></div><h3 id="Point-Variables"><a class="docs-heading-anchor" href="#Point-Variables">Point Variables</a><a id="Point-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Variables" title="Permalink"></a></h3><p>Now let&#39;s add some point variables. These allow us to consider an infinite variable evaluated at a certain infinite parameter point. For example, let&#39;s define a point variable for <code>y(0)</code> with the alias <code>y0</code> that is fixed at a value of 0:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, y0 == 0, Point(y, 0))
y0</code></pre><p>Here we create a Julia variable <code>y0</code> which points to the point variable <code>y(0)</code>. Notice that in the second argument we specify the infinite variable indexed at the appropriate parameter value(s). Point variables automatically inherit attributes of the infinite variable (e.g., bounds, start values, etc.), but these are overwritten with properties specified for the point variable. In this case the lower bound inherited from <code>y(t)</code> is overwritten by instead fixing <code>y(0)</code> to a value of 0.  </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Point variables are provided for enhancing the generality of <code>InfiniteOpt</code>, but typically can be avoided by using infinite variables in combination with adding <a href="../constraint/#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> to constraints which  restrict the infinite domain as needed.</p></div></div><h3 id="Finite-Variables"><a class="docs-heading-anchor" href="#Finite-Variables">Finite Variables</a><a id="Finite-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Variables" title="Permalink"></a></h3><p>Finally, we can add finite variables to our model. These denote variables that hold a single value over the infinite domain or some portion of it (e.g., design variables, first stage variables, etc.). Let&#39;s add a finite variable <span>$0 \leq d \leq 42$</span> that is an integer variable and defined over all infinite domains (i.e., time and space):</p><pre><code class="language-julia-repl">julia&gt; @variable(model, 0 &lt;= d &lt;= 42, Int)
d</code></pre><p>This creates a Julia variable <code>d</code> that points to the finite variable <code>d</code> which has a lower bound of 0, an upper bound of 42, and is an integer variable. Thus, finite  variables are equivalent to those employed in <code>JuMP</code>.</p><p>Now we have defined variables that we can use in the objective, measures, and constraints. Please note that the above tutorial only shows a small portion of the capabilities and options available in defining variables. A full description is provided in the documentation below.</p><h2 id="Variable-Definition-Methodology"><a class="docs-heading-anchor" href="#Variable-Definition-Methodology">Variable Definition Methodology</a><a id="Variable-Definition-Methodology-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Definition-Methodology" title="Permalink"></a></h2><p>Defining/initializing a variable (what happens behind the scenes of the variable  macros) principally involves the following steps:</p><ol><li>Define the variable information pertaining to <code>JuMP.VariableInfo</code> (e.g.,  bounds, indicate if it is integer, etc.)</li><li>Construct a concrete subtype of <a href="#InfiniteOpt.InfOptVariableType"><code>InfOptVariableType</code></a> to specify the  desired type and its required additional information if appropriate</li><li>Build the variable object via <code>JuMP.build_variable</code></li><li>Add the variable object to an <code>InfiniteModel</code> and assign a name via  <code>JuMP.add_variable</code></li><li>Create a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> that points to the variable object  stored in the model</li></ol><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This methodology is presented for those wanting to learn more about the ins  and outs of variable definition. We recommend that all variables be created  via <code>@variable</code>. See <a href="#Macro-Variable-Definition">Macro Variable Definition</a>.</p></div></div><p>The <code>JuMP.VariableInfo</code> data structure stores the following variable information:</p><ul><li><code>has_lb::Bool</code>: Specifies a <code>Bool</code> it has a lower bound</li><li><code>lower_bound::Real</code>: Specifies lower bound value</li><li><code>has_ub::Bool</code>: Specifies a <code>Bool</code> it has a upper bound</li><li><code>upper_bound::Real</code>: Specifies upper bound value</li><li><code>has_fix::Bool</code>: Specifies a <code>Bool</code> it is fixed</li><li><code>fixed_value::Real</code>: Specifies the fixed value</li><li><code>has_start::Bool</code>: Specifies a <code>Bool</code> it has a start value</li><li><code>start::Union{Real, Function}</code>: Specifies the start guess value, this can be a                                 function for infinite variables that intakes a                                 support and maps it to a guess value (allowing                                 to specify guess trajectories)</li><li><code>binary</code>: Specifies <code>Bool</code> if it is binary</li><li><code>integer</code>: Specifies <code>Bool</code> if it is integer.</li></ul><p>Thus, the user specifies this information to prepare such an object:</p><pre><code class="language-julia-repl">julia&gt; info = VariableInfo(true, 0., true, 42., false, 0., false, 0., false, true);</code></pre><p>Here we specified a lower bound of 0, an upper bound of 42, and that it is integer valued.</p><p>The variable type objects (<code>InfOptVariableType</code> subtypes) are used with  <code>build_variable</code> to specify the desired variable type along with any additional  information needed for that type. For example, let&#39;s build an infinite variable  <code>y(t)</code> that has an lower bound of 0, an upper bound of 42, and is integer valued:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; info = VariableInfo(true, 0, true, 42, false, 0, false, 0, false, true);

julia&gt; inf_var = build_variable(error, info, Infinite(t));</code></pre><p>Thus, we create an <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a> object with the desired properties.</p><p>Once a variable has been built, it needs to be added to our <code>model</code> and a Julia variable should be defined to reference it. Variables are added via <a href="#JuMP.add_variable-Tuple{InfiniteModel,AbstractVariable,String}"><code>add_variable</code></a> which adds a variable object to the model, assigns a name to the variable, adds any constraints associated with the <code>JuMP.VariableInfo</code>, and returns an appropriate variable reference variable (a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>). For example, let&#39;s add <code>inf_var</code> to <code>model</code>:</p><pre><code class="language-julia-repl">julia&gt; var_ref = add_variable(model, inf_var, &quot;y&quot;)
y(t)</code></pre><p>Thus, we have added an infinite variable <code>y</code> that is parameterized by <code>t</code> with the variable information mentioned above and now have a <code>GeneralVariableRef</code> called <code>var_ref</code> that can be used in defining our infinite model.</p><p>Note that the use of <code>GeneralVariableRef</code>s and the corresponding concrete subtypes of <a href="../expression/#InfiniteOpt.DispatchVariableRef"><code>DispatchVariableRef</code></a>s is discussed on the <a href="../expression/#expr_page">Expressions</a> page.</p><h2 id="Macro-Variable-Definition"><a class="docs-heading-anchor" href="#Macro-Variable-Definition">Macro Variable Definition</a><a id="Macro-Variable-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-Variable-Definition" title="Permalink"></a></h2><p>The <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/variables/#JuMP.@variable"><code>@variable</code></a>  macro automates the variable definition process discussed above in the  <a href="#Variable-Definition-Methodology">Variable Definition Methodology</a> section via a straightforward symbolic  syntax. The only key difference is that non-anonymous macro calls will register  variable names to ensure they are not repeated. Anonymous macro calls forgo this  step and exactly follow the process described above. This section will highlight  the details of using this macro which is the recommended way to define variables.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><code>JuMP</code>&#39;s <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/variables/">documentation on variables</a>  is a good place to start since <code>InfiniteOpt</code> simply extends <code>JuMP</code> to  accommodate our additional variable types.</p></div></div><p>We directly build upon  <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/variables/#JuMP.@variable"><code>JuMP.@variable</code></a>  to create all of our decision variable types. To illustrate this via example,  let&#39;s setup a model with a variety of infinite parameters <span>$t \in [0,10]$</span>,  <span>$x \in [-1, 1]^3$</span>, and <span>$\xi \in \mathcal{N}(0, 1)$</span>:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, Distributions

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @infinite_parameter(model, x[1:3] in [-1, 1], independent = true);

julia&gt; @infinite_parameter(model, ξ ~ Normal());</code></pre><h3 id="Variable-Types"><a class="docs-heading-anchor" href="#Variable-Types">Variable Types</a><a id="Variable-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Types" title="Permalink"></a></h3><p>We specify the variable type by providing a subtype of <a href="#InfiniteOpt.InfOptVariableType"><code>InfOptVariableType</code></a>  as an extra positional argument:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, y, Infinite(t, x, ξ)) # explicit infinite variable
y(t, x, ξ)

julia&gt; @variable(model, ys, SemiInfinite(y, 0, x, ξ)) # explicit semi-infinite variable
ys

julia&gt; @variable(model, yp, Point(y, 0, [1, 1, 1], 0)) # explicit point variable
yp

julia&gt; @variable(model, z) # explicit finite variable
z</code></pre><p>For anonymous definition, we use the <code>variable_type</code> keyword argument instead:</p><pre><code class="language-julia-repl">julia&gt;  y = @variable(model, variable_type = Infinite(t, x, ξ)) # anon infinite variable
noname(t, x, ξ)

julia&gt; ys = @variable(model, variable_type = SemiInfinite(y, 0, x, ξ)) # anon semi-infinite variable
noname(0, [x[1], x[2], x[3]], ξ)

julia&gt; yp = @variable(model, variable_type = Point(y, 0, [1, 1, 1], 0)) # anon point variable
noname(0, [1, 1, 1], 0)

julia&gt; z = @variable(model) # anon finite variable
noname</code></pre><p>Please refer to <a href="#InfiniteOpt.Infinite"><code>Infinite</code></a>, <a href="#InfiniteOpt.SemiInfinite"><code>SemiInfinite</code></a>, and <a href="#InfiniteOpt.Point"><code>Point</code></a>  for more information.</p><h3 id="Variable-Names"><a class="docs-heading-anchor" href="#Variable-Names">Variable Names</a><a id="Variable-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Names" title="Permalink"></a></h3><p>Variable inherit their names from the symbolic literal given with explicit  definitions:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, myname, Infinite(t))
myname(t)</code></pre><p>This creates an infinite variable with name <code>&quot;myname&quot;</code> that is added to <code>model</code>  and creates a Julia variable <code>myname</code> that stores a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>  which points to the infinite variable in <code>model</code>.</p><p>We can overwrite the inherited name using the <code>base_name</code> keyword argument:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, myjlvar, Infinite(t), base_name = &quot;myname&quot;)
myname(t)</code></pre><p>This creates an infinite variable with name <code>&quot;myname&quot;</code> that is added to <code>model</code>  and creates a Julia variable <code>myjlvar</code> that stores a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>  which points to the infinite variable in <code>model</code>.</p><p>This syntax is particularly useful for anonymous variables to have meaningful  names:</p><pre><code class="language-julia-repl">julia&gt; myjlvar = @variable(model, variable_type = Infinite(t), base_name = &quot;myname&quot;)
myname(t)</code></pre><p>See the Queries and Modification sections further below for more information on  how to query/modify variable names.</p><h3 id="Variable-Bounds"><a class="docs-heading-anchor" href="#Variable-Bounds">Variable Bounds</a><a id="Variable-Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Bounds" title="Permalink"></a></h3><p>We can specify variable bounds in like manner to <code>JuMP</code> variables. Let&#39;s  demonstrate this with infinite variables: </p><pre><code class="language-julia-repl">julia&gt; @variable(model, y_lb &gt;= 0, Infinite(t, x)) # add w/ lower bound
y_lb(t, x)

julia&gt; @variable(model, y_ub &lt;= 10, Infinite(t, x)) # add w/ upper bound
y_ub(t, x)

julia&gt; @variable(model, 0 &lt;= y_bd &lt;= 10, Infinite(t, x)) # add w/ bounds
y_bd(t, x)

julia&gt; @variable(model, y_fix == 42, Infinite(t, x)) # add w/ fixed value 
y_fix(t, x)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When creating a variable with only a single bound and the value of the bound  is not an explicit numeric literal, the name of the variable must appear on  the left-hand side. Otherwise, the macro will error.</p><pre><code class="language-julia">@variable(model, 0 &lt;= y, Infinite(t)) # okay

a = 0
@variable(model, a &lt;= y, Infinite(t)) # bad 
@variable(model, y &gt;= a, Infinite(t)) # okay</code></pre></div></div><p>For anonymous definition, we use the <code>lower_bound</code> and <code>upper_bound</code>. Let&#39;s use  finite variables for example:</p><pre><code class="language-julia-repl">julia&gt; z_lb = @variable(model, lower_bound = 0, base_name = &quot;z_lb&quot;) # add w/ lower bound
z_lb

julia&gt; z_ub = @variable(model, upper_bound = 10, base_name = &quot;z_ub&quot;) # add w/ upper bound
z_ub

julia&gt; z_bd = @variable(model, lower_bound = 0, upper_bound = 10, 
                        base_name = &quot;z_bd&quot;) # add w/ bounds
z_bd

julia&gt; z_fix = @variable(model, lower_bound = 10, upper_bound = 10, 
                         base_name = &quot;z_fix&quot;) # ~add w/ fixed value 
z_fix</code></pre><p>Note that there isn&#39;t a keyword for fixing variables. Instead  <a href="#JuMP.fix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>fix</code></a> should be used. </p><p>See the Queries and Modification sections further below for more information on  how to query/modify variable bounds.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Point variables inherit all the bounds of their respective infinite variables  by default. This can be overwritten by specifying different ones at creation.</p><pre><code class="language-julia">@variable(model, y &gt;= 0, Infinite(t, x)) # has lower bound
@variable(model, yp == 0, Point(w, 0, [0, 0, 0])) # forces the point to be fixed</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Bounds cannot be specified on creation for semi-infinite variables. Note that  they will inherit these from the infinite variable they depend on. Additional  bound be created by directly adding constraints. For example:</p><pre><code class="language-julia">@variable(model, y &gt;= 0, Infinite(t, x)) # has lower bound
@variable(model, ys, SemiInfinite(w, 0, x)) # inherits the lower bound
@constraint(model, ys &lt;= 10) # add upper bound to ys</code></pre></div></div><h3 id="Variable-Integrality"><a class="docs-heading-anchor" href="#Variable-Integrality">Variable Integrality</a><a id="Variable-Integrality-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Integrality" title="Permalink"></a></h3><p>We can constrain the integrality of decision variables in like manner to <code>JuMP</code>  using the <code>Bin</code> and <code>Int</code> positional arguments for explicit macro definition:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, y_bin, Infinite(t, x), Bin) # add as binary variable
y_bin(t, x)

julia&gt; @variable(model, y_int, Infinite(t, x), Int) # add as integer variable
y_int(t, x)</code></pre><p>For anonymous definition, we use the <code>binary</code> and <code>integer</code> keyword arguments:</p><pre><code class="language-julia-repl">julia&gt; y_bin = @variable(model, variable_type = Infinite(t, x), binary = true)
noname(t, x)

julia&gt; y_int = @variable(model, variable_type = Infinite(t, x), integer = true)
noname(t, x)</code></pre><p>Moreover, we can add bounds as needed to constrain the domain of integer variables:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, 0 &lt;= y_int2 &lt;= 10, Infinite(t, x), Int)
y_int2(t, x)</code></pre><p>See the Queries and Modification sections further below for more information on  how to query/modify variable integralities.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Point variables inherit the integrality of their respective infinite variables  by default. This can be overwritten by specifying different ones at creation.</p><pre><code class="language-julia">@variable(model, y, Infinite(t, x), Bin) # is binary
@variable(model, yp, Point(w, 0, [0, 0, 0]), Int) # is integer</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Integrality cannot be specified for semi-infinite variables. Note that  they will inherit these from the infinite variable they depend on. ```</p></div></div><h3 id="Variable-Start-Values"><a class="docs-heading-anchor" href="#Variable-Start-Values">Variable Start Values</a><a id="Variable-Start-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Start-Values" title="Permalink"></a></h3><p>Optimization solvers often benefit from giving initial guesses for the optimal  decision variable values. Following <code>JuMP</code> vernacular, these are called start  values. We use the keyword <code>start</code> to specify these at variable creation:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, z_start, start = 42)
z_start</code></pre><p>Moreover, infinite variables can accept a function that specifies the start  value of over the range of its infinite parameters (e.g., a function that provides  an initial guess trajectory). For example, consider the difference between these  two infinite variables:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, y_uniform, Infinite(t), start = 0) # start with y(t) = 0
y_uniform(t)

julia&gt; @variable(model, y_sin, Infinite(t), start = sin) # start with y(t) = sin(t)
y_sin(t)</code></pre><p>Note that such start functions must be able to accept parameter values as  arguments that exactly match the format of the infinite parameters given in  <code>Infinite(params...)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Start values be specified for semi-infinite variables. Note that  they will inherit these from the infinite variable they depend on.</p></div></div><p>See the Queries and Modification sections further below for more information on  how to query/modify variable names.</p><h3 id="Variable-Containers"><a class="docs-heading-anchor" href="#Variable-Containers">Variable Containers</a><a id="Variable-Containers-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Containers" title="Permalink"></a></h3><p>Optimization problems often involve multi-dimensional decision variables. Luckily,  <code>JuMP</code> provides a versatile syntax for specifying collections (i.e., containers)  of variables. See  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/containers/">JuMP&#39;s container documentation</a>  for a thorough tutorial on the syntax. It uses <code>Array</code>s, <code>DenseAxisArray</code>s, and  <code>SparseAxisArray</code>s to contain the variable references created. Here  <code>DenseAxisArray</code>s and <code>SparseAxisArray</code>s allow the use of nontraditional indices  (i.e., can use indices that are not sequential integers).</p><p>To illustrate what this means, consider the two equivalent ways to define  a 3-dimensional vector of variables with indices <code>[1, 2, 3]</code>:</p><pre><code class="language-julia-repl">julia&gt; s = [0, 2, 1];

julia&gt; var_refs = @variable(model, [i = 1:3], start = s[i], base_name = &quot;z&quot;)
3-element Array{GeneralVariableRef,1}:
 z[1]
 z[2]
 z[3]

julia&gt; var_refs = Vector{GeneralVariableRef}(undef, 3);

julia&gt; for i in eachindex(var_refs)
          var_refs[i] = @variable(model, start = s[i], base_name = &quot;z&quot;)
       end</code></pre><p>Moreover, here are a few illustrative examples:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, z_dense[2:4])
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, 2:4
And data, a 3-element Array{GeneralVariableRef,1}:
 z_dense[2]
 z_dense[3]
 z_dense[4]

julia&gt; @variable(model, z_named[[:A, :C, :Z]])
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, Symbol[:A, :C, :Z]
And data, a 3-element Array{GeneralVariableRef,1}:
 z_named[A]
 z_named[C]
 z_named[Z]

julia&gt; @variable(model, z_sparse[i = 1:2, j = 1:2; i + j &lt;= 3])
JuMP.Containers.SparseAxisArray{GeneralVariableRef,2,Tuple{Int64,Int64}} with 3 entries:
  [1, 2]  =  z_sparse[1,2]
  [1, 1]  =  z_sparse[1,1]
  [2, 1]  =  z_sparse[2,1]</code></pre><p>The variable macro will by default automatically detect which container type  should be used. However, the user can specify a particular container type using  the <code>container</code> keyword. For example, if we want to use indices <code>a:b</code> where  <code>a = 1</code> and <code>b = 3</code>, a <code>DenseAxisArray</code> will be used by default, but we can  force it to be a regular <code>Array</code>:</p><pre><code class="language-julia-repl">julia&gt; a = 1; b = 3;

julia&gt; var_refs1 = @variable(model, [a:b], base_name = &quot;z&quot;)
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, 1:3
And data, a 3-element Array{GeneralVariableRef,1}:
 z[1]
 z[2]
 z[3]

julia&gt; var_refs2 = @variable(model, [a:b], base_name = &quot;z&quot;, container = Array)
3-element Array{GeneralVariableRef,1}:
 z[1]
 z[2]
 z[3]</code></pre><h3 id="Variable-Sets"><a class="docs-heading-anchor" href="#Variable-Sets">Variable Sets</a><a id="Variable-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Sets" title="Permalink"></a></h3><p>Like <code>JuMP</code> variables, we can constrain variables on creation to lie in  particular sets. This allows us to make semi-definite variables, cone constrained  variables, and more. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The set syntax is only supported with finite variables with <code>v0.21.8</code> of  JuMP. This limitation will be removed with the next release of JuMP. In the  meantime, other variable types can be constrained using <code>@constraint</code>.</p><pre><code class="language-julia">@variable(model, y_psd[1:2, 1:2], Infinite(t))
@constraint(model, y_psd in PSDCone())</code></pre></div></div><p>For example:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, z_psd[1:2, 1:2], PSD) # positive semi-definite variable matrix
2×2 LinearAlgebra.Symmetric{GeneralVariableRef,Array{GeneralVariableRef,2}}:
 z_psd[1,1]  z_psd[1,2]
 z_psd[1,2]  z_psd[2,2]

julia&gt; @variable(model, z_cone[1:3] in SecondOrderCone()) # 2nd order cone variables
3-element Array{GeneralVariableRef,1}:
 z_cone[1]
 z_cone[2]
 z_cone[3]</code></pre><p>Typically, variable sets can be defined symbolically using the syntax  <code>var in set</code>. For anonymous variables, the <code>set</code> keyword argument must be used:</p><pre><code class="language-julia-repl">julia&gt; z_cone = @variable(model, [1:3], set = SecondOrderCone())
3-element Array{GeneralVariableRef,1}:
 noname
 noname
 noname</code></pre><p>For more a thorough tutorial please see  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/variables/#Semidefinite-variables">JuMP&#39;s semi-definite documentation</a>  and/or <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/variables/#Variables-constrained-on-creation">JuMP&#39;s variables constrained on creation documentation</a>.</p><h3 id="Anonymous-Variables"><a class="docs-heading-anchor" href="#Anonymous-Variables">Anonymous Variables</a><a id="Anonymous-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Anonymous-Variables" title="Permalink"></a></h3><p>Above we talked showed the syntax for both explicit and anonymous variable  creation. Anonymous creation is typically helpful in the following situations:</p><ul><li>defining multiple variables with the same name</li><li>creating variables in user defined extensions</li><li>using nontraditional naming</li></ul><p>For anonymous variables, the only accepted positional arguments are the <code>model</code>  and the container expression <code>[indices...]</code>. Everything else must be specified  via keyword arguments <code>kwargs...</code> as shown in the subsections above.</p><pre><code class="language-julia">@variable(model, [indices...], kwargs...)</code></pre><p>For more information, see  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/variables/#Anonymous-JuMP-variables">JuMP&#39;s anonymous variable documentation</a>.</p><h3 id="The-@variables-Macro"><a class="docs-heading-anchor" href="#The-@variables-Macro">The <code>@variables</code> Macro</a><a id="The-@variables-Macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@variables-Macro" title="Permalink"></a></h3><p>When using many <code>@variable</code> calls, we can instead use  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/variables/#variables"><code>@variables</code></a> to  enhance the readability:</p><pre><code class="language-julia-repl">julia&gt; @variables(model, begin
           y1, Infinite(t, x)
           y2[i=1:2] &gt;= i, Infinite(t), (start = i, base_name = &quot;Y_$i&quot;)
           z2, Bin
       end)
</code></pre><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><p><code>InfiniteOpt</code> contains a large suite of methods to query information about variables. This suite is comprised of extensions to all current <code>JuMP</code> query methods and many more that are specific to <code>InfiniteOpt</code>. A number of the more commonly used ones are explained in this section, but all of the available methods are explained in the <a href="#var_methods">Methods/Macros</a> section (i.e., the manual) below.</p><h3 id="General-Information"><a class="docs-heading-anchor" href="#General-Information">General Information</a><a id="General-Information-1"></a><a class="docs-heading-anchor-permalink" href="#General-Information" title="Permalink"></a></h3><p>Here we describe some methods used to query general variable information such as the name. Variable names can be extracted via <a href="#JuMP.name-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>name</code></a> which returns the name of a variable. The index of a variable (where it is stored  in the infinite model) is accessed via  <a href="../expression/#JuMP.index-Tuple{GeneralVariableRef}"><code>index</code></a> and the infinite model it  belongs to is given by  <a href="../expression/#JuMP.owner_model-Tuple{GeneralVariableRef}"><code>owner_model</code></a>. These methods are demonstrated below:</p><pre><code class="language-julia-repl">julia&gt; name(y)
&quot;y&quot;

julia&gt; index(y)
InfiniteVariableIndex(2)

julia&gt; model_where_stored = owner_model(y);</code></pre><p>Also, <a href="#JuMP.all_variables-Tuple{InfiniteModel}"><code>num_variables</code></a> is useful in returning the total number of decision variables currently stored in an infinite model:</p><pre><code class="language-julia-repl">julia&gt; num_variables(model)
61

julia&gt; num_variables(model, PointVariable)
2</code></pre><p>Similarly, <a href="#JuMP.all_variables-Tuple{InfiniteModel}"><code>all_variables</code></a> returns a list of all the variables currently added to the model.</p><p>Finally, <a href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>variable_by_name</code></a> can be employed to return the appropriate <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> based off  of the variable name if it is unique. Returns <code>nothing</code> if such a name cannot be  found and errors if it is not unique. For example, we can request the reference  associated with <code>&quot;y_ub&quot;</code>:</p><pre><code class="language-julia-repl">julia&gt; variable_by_name(model, &quot;y_ub&quot;)
y_ub(t, x)</code></pre><h3 id="Variable-Constraint-Info"><a class="docs-heading-anchor" href="#Variable-Constraint-Info">Variable Constraint Info</a><a id="Variable-Constraint-Info-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Constraint-Info" title="Permalink"></a></h3><p>As described above, variables in <code>InfiniteOpt</code> can have constraints associated with them like <code>JuMP</code> variables. These constraints include:</p><ul><li>lower bounds</li><li>upper bounds</li><li>fixed values</li><li>binary valued</li><li>integer valued.</li></ul><p>Thus, a number of methods exist to query information about these constraints.</p><p>First, the <code>[has/is]_[variable constraint type]</code> methods indicate whether or  not a variable has that particular constraint type. For example, to query if a  variable <code>y_lb</code> has a lower bound we can use <a href="#JuMP.has_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>has_lower_bound</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(y_bd)
true</code></pre><p>Thus, <code>y_bd</code> does have a lower bound. The other methods are <a href="#JuMP.has_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>has_upper_bound</code></a>, <a href="#JuMP.is_fixed-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>is_fixed</code></a>, <a href="#JuMP.is_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>is_binary</code></a>, and <a href="#JuMP.is_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>is_integer</code></a>.</p><p>Next, the <code>[ConstraintType]Ref</code> methods return an appropriate explicit type <a href="../constraint/#InfiniteOpt.InfOptConstraintRef"><code>InfOptConstraintRef</code></a> that points to the constraint (errors if no such constraint exists). For example, the upper bound constraint of <code>y_bd</code> can be obtained via <a href="#JuMP.UpperBoundRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>UpperBoundRef</code></a>:</p><pre><code class="language-julia-repl">julia&gt; UpperBoundRef(y_bd)
y_bd(t, x) ≤ 10.0, ∀ t ∈ [0, 10], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1], x[3] ∈ [-1, 1]</code></pre><p>The other methods are <a href="#JuMP.LowerBoundRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>LowerBoundRef</code></a>, <a href="#JuMP.FixRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>FixRef</code></a>, <a href="#JuMP.BinaryRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>BinaryRef</code></a>, and <a href="#JuMP.IntegerRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>IntegerRef</code></a>.</p><p>Finally, variable constraints that entail values (i.e., lower bounds, upper bounds, and fixed values) have their values queried via the appropriate method. For example, the lower bound value of <code>y_bd</code> is obtained via <a href="#JuMP.lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>lower_bound</code></a>:</p><pre><code class="language-julia-repl">julia&gt; lower_bound(y_bd)
0.0</code></pre><p>Note these methods error when no such constraint is associated with the variable. The other methods are <a href="#JuMP.upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>upper_bound</code></a> and <a href="#JuMP.fix_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>fix_value</code></a>.</p><p>The start value can also be queried via  <a href="#JuMP.start_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>start_value</code></a> where nothing  is returned if not start value is specified:</p><pre><code class="language-julia-repl">julia&gt; start_value(var_refs[1])
0.0

julia&gt; start_value(yp)</code></pre><p>For infinite and semi-infinite variables, the <a href="../expression/#InfiniteOpt.start_value_function-Tuple{GeneralVariableRef}"><code>start_value_function</code></a>  should be used instead:</p><pre><code class="language-julia-repl">julia&gt; start_value_function(y_sin)
sin (generic function with 16 methods)</code></pre><h3 id="Variable-Use"><a class="docs-heading-anchor" href="#Variable-Use">Variable Use</a><a id="Variable-Use-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Use" title="Permalink"></a></h3><p><code>InfiniteOpt</code> defines a number of methods to track if and how variables are used in an infinite model. For example, <a href="#InfiniteOpt.used_by_constraint-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>used_by_constraint</code></a> is used to determine if a variable is used by a constraint. For example, let&#39;s see if <code>y_bd</code> is used by a constraint:</p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(y_bd)
true</code></pre><p>Other methods include <a href="#InfiniteOpt.used_by_measure-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>used_by_measure</code></a> and <a href="#InfiniteOpt.used_by_objective-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>used_by_objective</code></a>. For infinite variables, <a href="../expression/#InfiniteOpt.used_by_point_variable-Tuple{GeneralVariableRef}"><code>used_by_point_variable</code></a> can also be used in a similar manner.</p><p>Finally, in general <a href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>is_used</code></a> can be used to determine if a variable is used at all in the infinite model or not. For  example, if we check <code>yp</code> using <code>is_used</code> we find that it isn&#39;t:</p><pre><code class="language-julia-repl">julia&gt; is_used(yp)
false</code></pre><h3 id="Type-Specific"><a class="docs-heading-anchor" href="#Type-Specific">Type Specific</a><a id="Type-Specific-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Specific" title="Permalink"></a></h3><p><code>InfiniteOpt</code> also employs a few methods for specific variable types that return information pertaining to that particular variable type. For infinite variables  and semi-infinite variables, <a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>parameter_refs</code></a> returns the tuple of infinite parameters that the variable depends on. For example, consider <code>y(t, x)</code>:</p><pre><code class="language-julia-repl">julia&gt; parameter_refs(y)
(t, GeneralVariableRef[x[1], x[2], x[3]], ξ)</code></pre><p>For point variables, <a href="#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>infinite_variable_ref</code></a> and <a href="#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>parameter_values</code></a> return the infinite variable it depends on and the infinite parameter point values, respectively. For example, consider the point variable <code>yp</code>:</p><pre><code class="language-julia-repl">julia&gt; infinite_variable_ref(yp)
y(t, x, ξ)

julia&gt; parameter_values(yp)
(0.0, [1.0, 1.0, 1.0], 0.0)</code></pre><h2 id="Modification"><a class="docs-heading-anchor" href="#Modification">Modification</a><a id="Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Modification" title="Permalink"></a></h2><p><code>InfiniteOpt</code> employs a wide variety of methods to modify/delete variables. These are comprised of <code>JuMP</code> extensions and methods native only to <code>InfiniteOpt</code>. This section will highlight some of the more commonly used ones. All of the methods/macros are detailed in the <a href="#var_methods">Methods/Macros</a> section (i.e., the manual) below.</p><h3 id="Deletion"><a class="docs-heading-anchor" href="#Deletion">Deletion</a><a id="Deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Deletion" title="Permalink"></a></h3><p>Like <code>JuMP v0.19+</code>, <code>InfiniteOpt</code> fully supports deletion throughout its data types. Any variable and its dependencies can be deleted via <a href="#JuMP.delete-Tuple{InfiniteModel,Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>delete</code></a>. Thus, when  <code>delete</code> is invoked any bound/type constraints associated with the variable will  be removed and it will be removed from any other constraints, measures, and/or  objectives. For example, if we delete <code>y(t, x, ξ)</code> it will be removed along with  its  bounds and the point variable <code>yp</code> will also be removed since it is a  dependent:</p><pre><code class="language-julia-repl">julia&gt; delete(model, y)

julia&gt; is_valid(model, yp)
false</code></pre><p>Another class of deletion methods correspond to variable constraints. For example, <a href="#JuMP.delete_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>delete_lower_bound</code></a> is used to delete a lower bound associated with a variable if it has one. Let&#39;s illustrate this by deleting the lower bound of <code>y_bd</code>:</p><pre><code class="language-julia-repl">julia&gt; delete_lower_bound(y_bd)

julia&gt; has_lower_bound(y_bd)
false</code></pre><p>Other similar methods are <a href="#JuMP.delete_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>delete_upper_bound</code></a>, <a href="#JuMP.unfix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>unfix</code></a>, <a href="#JuMP.unset_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>unset_binary</code></a>, and <a href="#JuMP.unset_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>unset_integer</code></a>.</p><h3 id="Variable-Constraints"><a class="docs-heading-anchor" href="#Variable-Constraints">Variable Constraints</a><a id="Variable-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Constraints" title="Permalink"></a></h3><p>Another class of methods seek to add/modify variable constraints such as bounds. For example, <a href="#JuMP.set_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>set_lower_bound</code></a> specifies the lower bound of a variable. We can add a lower bound of 0 to <code>z</code> by:</p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(z, 0)

julia&gt; lower_bound(z)
0.0</code></pre><p>Thus, adding a lower bound to <code>z</code>. Furthermore, we can later modify the lower bound using the same method:</p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(z, -2)

julia&gt; lower_bound(z)
-2.0</code></pre><p>Other similar methods are <a href="#JuMP.set_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>set_upper_bound</code></a>, <a href="#JuMP.fix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>fix</code></a>, <a href="#JuMP.set_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>set_binary</code></a>, and <a href="#JuMP.set_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>set_integer</code></a>.</p><h3 id="Start-Values"><a class="docs-heading-anchor" href="#Start-Values">Start Values</a><a id="Start-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Start-Values" title="Permalink"></a></h3><p>We can update the start value of a variable using  <a href="#JuMP.set_start_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>set_start_value</code></a>. For example:</p><pre><code class="language-julia-repl">julia&gt; set_start_value(z, 0)

julia&gt; start_value(z)
0.0</code></pre><p>For infinite variables, this should be done using  <a href="../derivative/#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef,Union{Function, Real}}"><code>set_start_value_function</code></a>. FOr example:</p><pre><code class="language-julia-repl">julia&gt; set_start_value_function(myname, sin)

julia&gt; start_value_function(myname)
sin (generic function with 16 methods)</code></pre><p>Again note that such start functions must be able to accept parameter values as  arguments that exactly match the format of the infinite parameters given in  <code>Infinite(params...)</code>.</p><p>A number of other techniques exist for the various variable types can be found in  the manual below.</p><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.FiniteVariableIndex"><code>InfiniteOpt.FiniteVariableIndex</code></a></li><li><a href="#InfiniteOpt.FiniteVariableRef"><code>InfiniteOpt.FiniteVariableRef</code></a></li><li><a href="#InfiniteOpt.InfOptVariableType"><code>InfiniteOpt.InfOptVariableType</code></a></li><li><a href="#InfiniteOpt.Infinite"><code>InfiniteOpt.Infinite</code></a></li><li><a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteOpt.InfiniteVariable</code></a></li><li><a href="#InfiniteOpt.InfiniteVariableIndex"><code>InfiniteOpt.InfiniteVariableIndex</code></a></li><li><a href="#InfiniteOpt.InfiniteVariableRef"><code>InfiniteOpt.InfiniteVariableRef</code></a></li><li><a href="#InfiniteOpt.Point"><code>InfiniteOpt.Point</code></a></li><li><a href="#InfiniteOpt.PointVariable"><code>InfiniteOpt.PointVariable</code></a></li><li><a href="#InfiniteOpt.PointVariableIndex"><code>InfiniteOpt.PointVariableIndex</code></a></li><li><a href="#InfiniteOpt.PointVariableRef"><code>InfiniteOpt.PointVariableRef</code></a></li><li><a href="#InfiniteOpt.SemiInfinite"><code>InfiniteOpt.SemiInfinite</code></a></li><li><a href="#InfiniteOpt.SemiInfiniteVariable"><code>InfiniteOpt.SemiInfiniteVariable</code></a></li><li><a href="#InfiniteOpt.SemiInfiniteVariableIndex"><code>InfiniteOpt.SemiInfiniteVariableIndex</code></a></li><li><a href="#InfiniteOpt.SemiInfiniteVariableRef"><code>InfiniteOpt.SemiInfiniteVariableRef</code></a></li><li><a href="#InfiniteOpt.VariableData"><code>InfiniteOpt.VariableData</code></a></li><li><a href="#InfiniteOpt.Collections.VectorTuple"><code>InfiniteOpt.Collections.VectorTuple</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptVariableType" href="#InfiniteOpt.InfOptVariableType"><code>InfiniteOpt.InfOptVariableType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfOptVariableType</code></pre><p>An abstract <code>DataType</code> for variable type objects used to create <code>InfiniteOpt</code>  variables via <code>JuMP.@variable</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Infinite" href="#InfiniteOpt.Infinite"><code>InfiniteOpt.Infinite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Infinite{VT &lt;: VectorTuple} &lt;: InfOptVariableType</code></pre><p>A <code>DataType</code> to assist in making infinite variables. This can be passed as an  extra argument to <code>@variable</code> to make an infinite variable: </p><pre><code class="language-julia">@variable(model, var_expr, Infinite(parameter_refs...), args..., kwargs...)</code></pre><p>Here <code>parameter_refs</code> can be a single parameter reference, a single parameter  array with parameters defined in the same macro call, or multiple arguments where  each argument is either of the first two options listed.</p><p><strong>Fields</strong></p><ul><li><code>parameter_refs::VT</code>: The infinite parameters the variable will depend on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL104-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.SemiInfinite" href="#InfiniteOpt.SemiInfinite"><code>InfiniteOpt.SemiInfinite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemiInfinite{V, VT &lt;: VectorTuple} &lt;: InfOptVariableType</code></pre><p>A <code>DataType</code> to assist in making semi-infinite variables. This can be passed as an  extra argument to <code>@variable</code> to make such a variable: </p><pre><code class="language-julia">@variable(model, var_expr, SemiInfinite(inf_var, parameter_values...), kwargs...)</code></pre><p>Here <code>parameter_values</code> must match the format of the infinite parameter  references associated with the infinite variable <code>inf_var</code> and can be comprised  of both real valued supports and/or infinite parameters.</p><p><strong>Fields</strong></p><ul><li><code>infinite_variable_ref::V</code></li><li><code>parameter_values::VT</code>: The infinite parameters and/or infinite   parameter support values the variable will depend on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL101-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Point" href="#InfiniteOpt.Point"><code>InfiniteOpt.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Point{V, VT &lt;: VectorTuple} &lt;: InfOptVariableType</code></pre><p>A <code>DataType</code> to assist in making point variables. This can be passed as an  extra argument to <code>@variable</code> to make such a variable: </p><pre><code class="language-julia">@variable(model, var_expr, Point(inf_var, parameter_values...), args..., 
          kwargs...)</code></pre><p>Here <code>parameter_values</code> must match the format of the infinite parameter  references associated with the infinite variable <code>inf_var</code> and can be comprised  of both real valued supports.</p><p><strong>Fields</strong></p><ul><li><code>infinite_variable_ref::V</code></li><li><code>parameter_values::VT</code>: The infinite parameter support values the   variable will depend on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/point_variables.jl#LL55-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteVariable" href="#InfiniteOpt.InfiniteVariable"><code>InfiniteOpt.InfiniteVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteVariable{F &lt;: Function, VT &lt;: VectorTuple} &lt;: JuMP.AbstractVariable</code></pre><p>A <code>DataType</code> for storing core infinite variable information. Note that indices that refer to the same dependent parameter group must be in the same tuple element. It is important to note that <code>info.start</code> should contain a start value function that generates the start value for a given infinite parameter support. This function should map a support to a start value using user-formatting if <code>is_vector_start = false</code>, otherwise it should do the mapping using a single support vector as input.</p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{Float64, Float64, Float64, F}</code>: JuMP variable information. Here the start value is a function that maps the parameter values to a start value.</li><li><code>parameter_refs::VT</code>: The infinite parameter references that parameterize the  variable.</li><li><code>parameter_nums::Vector{Int}</code>: The parameter numbers of <code>parameter_refs</code>.</li><li><code>object_nums::Vector{Int}</code>: The parameter object numbers associated with <code>parameter_refs</code>.</li><li><code>is_vector_start::Bool</code>: Does the start function take support values formatted as vectors?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL735-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.SemiInfiniteVariable" href="#InfiniteOpt.SemiInfiniteVariable"><code>InfiniteOpt.SemiInfiniteVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemiInfiniteVariable{I &lt;: GeneralVariableRef} &lt;: JuMP.AbstractVariable</code></pre><p>A <code>DataType</code> for storing semi-infinite variables which partially support an infinite variable.</p><p><strong>Fields</strong></p><ul><li><code>infinite_variable_ref::I</code>: The original infinite/derivvative variable.</li><li><code>eval_supports::Dict{Int, Float64}</code>: The original parameter tuple linear indices                                    to the evaluation supports.</li><li><code>parameter_nums::Vector{Int}</code>: The parameter numbers associated with the evaluated                                <code>parameter_refs</code>.</li><li><code>object_nums::Vector{Int}</code>: The parameter object numbers associated with the                             evaluated <code>parameter_refs</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL763-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.PointVariable" href="#InfiniteOpt.PointVariable"><code>InfiniteOpt.PointVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointVariable{I &lt;: GeneralVariableRef} &lt;: JuMP.AbstractVariable</code></pre><p>A <code>DataType</code> for storing point variable information. Note that the elements <code>parameter_values</code> field must match the format of the parameter reference tuple defined in <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a></p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{Float64, Float64, Float64, Float64}</code>: JuMP Variable information.</li><li><code>infinite_variable_ref::I</code>: The infinite variable/derivative reference   associated with the point variable.</li><li><code>parameter_values::Vector{Float64}</code>: The infinite parameter values   defining the point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL785-L798">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.VariableData" href="#InfiniteOpt.VariableData"><code>InfiniteOpt.VariableData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VariableData{V &lt;: JuMP.AbstractVariable} &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing variables and their data.</p><p><strong>Fields</strong></p><ul><li><code>variable::V</code>: The scalar variable.</li><li><code>name::String</code>: The name used for printing.</li><li><code>lower_bound_index::Union{InfOptConstraintIndex, Nothing}</code>: Index of lower bound constraint.</li><li><code>upper_bound_index::Union{InfOptConstraintIndex, Nothing}</code>: Index of upper bound constraint.</li><li><code>fix_index::Union{InfOptConstraintIndex, Nothing}</code>: Index on fixing constraint.</li><li><code>zero_one_index::Union{InfOptConstraintIndex, Nothing}</code>: Index of binary constraint.</li><li><code>integrality_index::Union{InfOptConstraintIndex, Nothing}</code>: Index of integer constraint.</li><li><code>measure_indices::Vector{MeasureIndex}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{InfOptConstraintIndex}</code>: Indices of dependent constraints.</li><li><code>in_objective::Bool</code>: Is this used in objective?</li><li><code>point_var_indices::Vector{PointVariableIndex}</code>: Indices of dependent point variables.</li><li><code>semi_infinite_var_indices::Vector{SemiInfiniteVariableIndex}</code>: Indices of dependent semi-infinite variables.</li><li><code>derivative_indices::Vector{DerivativeIndex}</code>: Indices of dependent derivatives.</li><li><code>deriv_constr_indices::Vector{InfOptConstraintIndex}</code>: Indices of dependent derivative evaluation constraints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL805-L825">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteVariableIndex" href="#InfiniteOpt.InfiniteVariableIndex"><code>InfiniteOpt.InfiniteVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.SemiInfiniteVariableIndex" href="#InfiniteOpt.SemiInfiniteVariableIndex"><code>InfiniteOpt.SemiInfiniteVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemiInfiniteVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.SemiInfiniteVariable"><code>SemiInfiniteVariable</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.PointVariableIndex" href="#InfiniteOpt.PointVariableIndex"><code>InfiniteOpt.PointVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.PointVariable"><code>PointVariable</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FiniteVariableIndex" href="#InfiniteOpt.FiniteVariableIndex"><code>InfiniteOpt.FiniteVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <code>JuMP.ScalarVariable</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteVariableRef" href="#InfiniteOpt.InfiniteVariableRef"><code>InfiniteOpt.InfiniteVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteVariableRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for untranscripted infinite dimensional variable references (e.g., second stage variables, time dependent variables).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::InfiniteVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL1548-L1557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.SemiInfiniteVariableRef" href="#InfiniteOpt.SemiInfiniteVariableRef"><code>InfiniteOpt.SemiInfiniteVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemiInfiniteVariableRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::SemiInfiniteVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL1563-L1573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.PointVariableRef" href="#InfiniteOpt.PointVariableRef"><code>InfiniteOpt.PointVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointVariableRef &lt;: FiniteRef</code></pre><p>A <code>DataType</code> for variables defined at a transcipted point (e.g., second stage variable at a particular scenario, dynamic variable at a discretized time point).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::PointVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL1614-L1623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FiniteVariableRef" href="#InfiniteOpt.FiniteVariableRef"><code>InfiniteOpt.FiniteVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteVariableRef &lt;: FiniteRef</code></pre><p>A <code>DataType</code> for finite fixed variable references (e.g., first stage variables, steady-state variables).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::FiniteVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/datatypes.jl#LL1629-L1638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Collections.VectorTuple" href="#InfiniteOpt.Collections.VectorTuple"><code>InfiniteOpt.Collections.VectorTuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorTuple{T, I &lt;: Tuple}</code></pre><p>A collection DataType for storing a <code>Tuple</code> of singular elements of type <code>T</code> and/or <code>AbstractArray{&lt;:T}</code>s in a convenient vector form that utilizes linear indexing. Here <code>I</code> is denotes the type of a <code>Tuple</code> that stores the  indices of each tuple element as given by <code>indices</code>. <code>VectorTuple</code>s should be  defined from an original tuple via <code>VectorTuple(tuple)</code> or by listing the tuple  elements <code>VectorTuple(items...)</code>. Note this is still an experimental type and is  primarily intended to store infinite parameter reference tuples and point  variable support value tuples. Some of the notable capabilities are exemplified  below.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tuple = (3, [-2, 4], ones(2, 2))
(3, [-2, 4], [1.0 1.0; 1.0 1.0])

julia&gt; vt = VectorTuple(tuple) # make by listing items (notice everything is a vector)
([3.0], [3.0, 4.0], [1.0, 1.0, 1.0, 1.0])

julia&gt; vt[2] # linear indexing
-2.0

julia&gt; vt[2, 2] # tuple indexing (note the second index is treated linearly)
4.0

julia&gt; vt[6:end] # linear slicing
2-element Array{Float64,1}:
 1.0
 1.0

julia&gt; vt[2:3, :] # tuple slicing
2-element Array{Array{Float64,1},1}:
 [-2.0, 4.0]
 [1.0, 1.0, 1.0, 1.0]

julia&gt; tuple2 = Tuple(vt) # rebuild original Tuple with original indices
([3.0], [-2.0, 4.0], [1.0 1.0; 1.0 1.0])

julia&gt; inds = [true, true, true, false, true, true, true];

julia&gt; restricted_copy(vt, delete_locs) # make a copy with deleted elements
([3.0], [-2.0, 4.0], [1.0, 1.0, 1.0])

julia&gt; Tuple(vt) # The 3rd element becomes a SparseAxisArray because of deletion
([3.0], [-2.0, 4.0],   [1, 2]  =  1.0
  [2, 2]  =  1.0
  [2, 1]  =  1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/Collections/VectorTuple.jl#LL1-L51">source</a></section></article><h2 id="var_methods"><a class="docs-heading-anchor" href="#var_methods">Methods/Macros</a><a id="var_methods-1"></a><a class="docs-heading-anchor-permalink" href="#var_methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.eval_supports-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.parameter_list-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a></li><li><a href="#InfiniteOpt.parameter_list-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.parameter_values</code></a></li><li><a href="#InfiniteOpt.raw_parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a></li><li><a href="#InfiniteOpt.raw_parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a></li><li><a href="#InfiniteOpt.raw_parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.raw_parameter_values</code></a></li><li><a href="#InfiniteOpt.reset_start_value_function-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.reset_start_value_function</code></a></li><li><a href="#InfiniteOpt.set_start_value_function-Tuple{InfiniteVariableRef,Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a></li><li><a href="#InfiniteOpt.start_value_function-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.start_value_function</code></a></li><li><a href="#InfiniteOpt.start_value_function-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.start_value_function</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#InfiniteOpt.used_by_point_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.used_by_point_variable</code></a></li><li><a href="#InfiniteOpt.used_by_semi_infinite_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.used_by_semi_infinite_variable</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.add_variable-Tuple{InfiniteModel,AbstractVariable,String}"><code>JuMP.add_variable</code></a></li><li><a href="#JuMP.all_variables-Tuple{InfiniteModel}"><code>JuMP.all_variables</code></a></li><li><a href="#JuMP.build_variable-Tuple{Function,VariableInfo,Infinite}"><code>JuMP.build_variable</code></a></li><li><a href="#JuMP.build_variable-Tuple{Function,VariableInfo,Point}"><code>JuMP.build_variable</code></a></li><li><a href="#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a></li><li><a href="#JuMP.build_variable-Tuple{Function,VariableInfo,SemiInfinite}"><code>JuMP.build_variable</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_lower_bound</code></a></li><li><a href="#JuMP.delete_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_upper_bound</code></a></li><li><a href="#JuMP.fix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.fix</code></a></li><li><a href="#JuMP.fix_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.fix_value-Tuple{SemiInfiniteVariableRef}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.is_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_binary-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_fixed-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_fixed-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.is_integer-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.lower_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.name-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>JuMP.name</code></a></li><li><a href="#JuMP.num_variables-Tuple{InfiniteModel}"><code>JuMP.num_variables</code></a></li><li><a href="#JuMP.relax_integrality-Tuple{InfiniteModel}"><code>JuMP.relax_integrality</code></a></li><li><a href="#JuMP.set_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_binary</code></a></li><li><a href="#JuMP.set_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_integer</code></a></li><li><a href="#JuMP.set_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_lower_bound</code></a></li><li><a href="#JuMP.set_name-Tuple{SemiInfiniteVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef},String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_start_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_start_value</code></a></li><li><a href="#JuMP.set_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_upper_bound</code></a></li><li><a href="#JuMP.start_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.start_value</code></a></li><li><a href="#JuMP.unfix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unfix</code></a></li><li><a href="#JuMP.unset_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_binary</code></a></li><li><a href="#JuMP.unset_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_integer</code></a></li><li><a href="#JuMP.upper_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>JuMP.variable_by_name</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function,VariableInfo,Infinite}" href="#JuMP.build_variable-Tuple{Function,VariableInfo,Infinite}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, info::JuMP.VariableInfo, 
                    var_type::Infinite)::InfiniteVariable{GeneralVariableRef}</code></pre><p>Build and return an infinite variable based on <code>info</code> and <code>var_type</code>. Errors if  the infinite parameter references included in <code>var_type</code> are invalid. See  <a href="#InfiniteOpt.Infinite"><code>Infinite</code></a> for more information.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);

julia&gt; inf_var = build_variable(error, info, Infinite(t));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL232-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function,VariableInfo,SemiInfinite}" href="#JuMP.build_variable-Tuple{Function,VariableInfo,SemiInfinite}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, info::JuMP.VariableInfo, 
                    var_type::SemiInfinite)::SemiInfiniteVariable{GeneralVariableRef}</code></pre><p>Build and return a semi-infinite variable based on <code>info</code> and <code>var_type</code>. Errors  if the information stored in <code>var_type</code> is invalid. See <a href="#InfiniteOpt.SemiInfinite"><code>SemiInfinite</code></a>  for more information.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; y
y(t, x)

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);

julia&gt; semi_inf_var = build_variable(error, info, SemiInfinite(y, t, 0));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL131-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}" href="#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, ivref::GeneralVariableRef,
                    eval_supports::Dict{Int, Float64}; [check::Bool = true]
                    )::SemiInfiniteVariable{GeneralVariableRef}</code></pre><p>Extend the <code>JuMP.build_variable</code> function to build a semi-infinite variable based on the infinite variable/derivative/parameter function <code>ivref</code> with  reduction support <code>eval_supports</code>. Will check that input is appropriate if  <code>check = true</code>. Errors if <code>ivref</code> is not an infinite variable, <code>eval_supports</code>  violate infinite parameter domains, or if the support dimensions don&#39;t match the  infinite parameter dimensions of <code>ivref</code>. This is intended an internal method for  use in evaluating measures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL188-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function,VariableInfo,Point}" href="#JuMP.build_variable-Tuple{Function,VariableInfo,Point}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, info::JuMP.VariableInfo, 
                    var_type::Point)::InfiniteVariable{GeneralVariableRef}</code></pre><p>Build and return a point variable based on <code>info</code> and <code>var_type</code>. Errors  if the information stored in <code>var_type</code> is invalid. See <a href="#InfiniteOpt.Point"><code>Point</code></a>  for more information.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; y
y(t)

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);

julia&gt; pt_var = build_variable(error, info, SemiInfinite(y, 0));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/point_variables.jl#LL201-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_variable-Tuple{InfiniteModel,AbstractVariable,String}" href="#JuMP.add_variable-Tuple{InfiniteModel,AbstractVariable,String}"><code>JuMP.add_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_variable(model::InfiniteModel, var::JuMP.AbstractVariable,
                  [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Extend the <code>JuMP.add_variable</code> function to accomodate <code>InfiniteOpt</code> variable  types. Adds a variable to an infinite model <code>model</code> and returns a  <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>. Primarily intended to be an internal function of  the constructor macro <code>@variable</code>. However, it can be used in combination with <code>JuMP.build_variable</code> to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in <code>var</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 10]);

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);

julia&gt; inf_var = build_variable(error, info, Infinite(t));

julia&gt; ivref = add_variable(m, inf_var, &quot;var_name&quot;)
var_name(t)

julia&gt; pt_var = build_variable(error, info, Point(ivref, 0.5));

julia&gt; pvref = add_variable(m, pt_var, &quot;var_alias&quot;)
var_alias

julia&gt; f_var = build_variable(error, info);

julia&gt; fvref = add_variable(m, f_var, &quot;var_name&quot;)
var_name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL54-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}" href="#InfiniteOpt.used_by_constraint-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(vref::DecisionVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL158-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}" href="#InfiniteOpt.used_by_measure-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(vref::DecisionVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL143-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}" href="#InfiniteOpt.used_by_objective-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_objective(vref::DecisionVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_objective(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL173-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}" href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(vref::DecisionVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL188-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_point_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}" href="#InfiniteOpt.used_by_point_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.used_by_point_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_point_variable(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a point variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_point_variable(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL354-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_semi_infinite_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}" href="#InfiniteOpt.used_by_semi_infinite_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.used_by_semi_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_semi_infinite_variable(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a semi-infinite variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_semi_infinite_variable(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL337-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{Union{DerivativeRef, InfiniteVariableRef}}" href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL386-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}" href="#JuMP.delete-Tuple{InfiniteModel,Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, vref::DecisionVariableRef)::Nothing</code></pre><p>Extend <code>JuMP.delete</code> to delete <code>InfiniteOpt</code> variables and their dependencies.  Errors if variable is invalid, meaning it has already been deleted or it belongs  to another model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0

julia&gt; delete(model, g)

julia&gt; print(model)
Min measure(t) + z
Subject to
 z ≥ 0.0
 z ≥ 42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL1145-L1169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_variables-Tuple{InfiniteModel}" href="#JuMP.num_variables-Tuple{InfiniteModel}"><code>JuMP.num_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_variables(model::InfiniteModel, [type])::Int</code></pre><p>Extend <code>JuMP.num_variables</code> to return the number of <code>InfiniteOpt</code> variables  assigned to <code>model</code>. By default, the total number of infinite, semi-infinite,  point, and finite variables is returned. The amount of a particular type is  obtained by specifying the concrete variable type via <code>type</code>. Type options  include:</p><ul><li><code>InfiniteVariable</code>: all infinite variables</li><li><code>SemiInfiniteVariable</code>: all semi-infinite variables</li><li><code>PointVariable</code>: all point variables</li><li><code>FiniteVariable</code>: all finite variables</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_variables(model)
3

julia&gt; num_variables(model, InfiniteVariable)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL1041-L1062">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_variables-Tuple{InfiniteModel}" href="#JuMP.all_variables-Tuple{InfiniteModel}"><code>JuMP.all_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_variables(model::InfiniteModel, [type])::Vector{GeneralVariableRef}</code></pre><p>Extend <code>JuMP.all_variables</code>] to return a list of all the variable references  associated with <code>model</code>. By default, all of the infinite, semi-infinite, point,  and finite variables is returned. Those of a particular type is obtained by  specifying the concrete variable type via <code>type</code>. Type options include:</p><ul><li><code>InfiniteVariable</code>: all infinite variables</li><li><code>SemiInfiniteVariable</code>: all semi-infinite variables</li><li><code>PointVariable</code>: all point variables</li><li><code>FiniteVariable</code>: all finite variables</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all_variables(model)
4-element Array{GeneralVariableRef,1}:
 y(t)
 w(t, x)
 y(0)
 z

julia&gt; all_variables(model, PointVariable)
1-element Array{GeneralVariableRef,1}:
 y(0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL1077-L1102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}" href="#JuMP.name-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef}}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(vref::DecisionVariableRef)::String</code></pre><p>Extend <code>JuMP.name</code> to return the names of <code>InfiniteOpt</code> variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(vref)
&quot;var_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL206-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef},String}" href="#JuMP.set_name-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef, SemiInfiniteVariableRef},String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing</code></pre><p>Extend <code>JuMP.set_name</code> to set names of decision variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(vref, &quot;var_name&quot;)

julia&gt; name(vref)
&quot;var_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL222-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{SemiInfiniteVariableRef,String}" href="#JuMP.set_name-Tuple{SemiInfiniteVariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing</code></pre><p>Extend <code>JuMP.set_name</code> to set names of decision variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(vref, &quot;var_name&quot;)

julia&gt; name(vref)
&quot;var_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL222-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.variable_by_name-Tuple{InfiniteModel,String}" href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>JuMP.variable_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.variable_by_name(model::InfiniteModel,
                      name::String)::Union{GeneralVariableRef, Nothing}</code></pre><p>Extend <code>JuMP.variable_by_name</code> for <code>InfiniteModel</code> objects. Return the variable  reference assoociated with a variable name. Errors if multiple variables have the  same name. Returns nothing if no such name exists.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; variable_by_name(m, &quot;var_name&quot;)
var_name

julia&gt; variable_by_name(m, &quot;fake_name&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL274-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.has_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <code>JuMP.has_lower_bound</code> to return a <code>Bool</code> whether an <code>InfiniteOpt</code>  variable has a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL340-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(vref::UserDecisionVariableRef)::Float64</code></pre><p>Extend <code>JuMP.lower_bound</code> to return the lower bound of an <code>InfiniteOpt</code> variable.  Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL356-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}" href="#JuMP.set_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_lower_bound(vref::UserDecisionVariableRef, lower::Real)::Nothing</code></pre><p>Extend <code>JuMP.set_lower_bound</code> to specify the lower bound of an <code>InfiniteOpt</code>  variable <code>vref</code>. Errors if <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(vref, -1)

julia&gt; lower_bound(vref)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL392-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.LowerBoundRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.LowerBoundRef</code> to extract a constraint reference for the lower  bound of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">var ≥ 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL433-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.delete_lower_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete_lower_bound(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <code>JuMP.delete_lower_bound</code> to delete lower bound of <code>vref</code>. Errors if it  doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_lower_bound(vref)

julia&gt; has_lower_bound(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL450-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.has_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <code>JuMP.has_upper_bound</code> to return a <code>Bool</code> whether an <code>InfiniteOpt</code>  variable has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL476-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(vref::UserDecisionVariableRef)::Float64</code></pre><p>Extend <code>JuMP.upper_bound</code> to return the upper bound of an <code>InfiniteOpt</code> variable.  Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL492-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}" href="#JuMP.set_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_upper_bound(vref::UserDecisionVariableRef, upper::Real)::Nothing</code></pre><p>Extend <code>JuMP.set_upper_bound</code> to specify the upper bound of an <code>InfiniteOpt</code>  variable <code>vref</code>. Errors if <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_upper_bound(vref, 1)

julia&gt; upper_bound(vref)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL528-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.UpperBoundRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.UpperBoundRef</code> to extract a constraint reference for the upper  bound of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = UpperBoundRef(vref)
var ≤ 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL569-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.delete_upper_bound-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete_upper_bound(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <code>JuMP.delete_upper_bound</code> to delete the upper bound of <code>vref</code>. Errors if  it doesn&#39;t have an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_upper_bound(vref)

julia&gt; has_upper_bound(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL587-L600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_fixed-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_fixed(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <code>JuMP.is_fixed</code> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is  fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_fixed(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL613-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.fix_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix_value(vref::UserDecisionVariableRef)::Float64</code></pre><p>Extend <code>JuMP.fix_value</code> to return the fix value of an <code>InfiniteOpt</code> variable.  Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fix_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL627-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}" href="#JuMP.fix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.fix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix(vref::UserDecisionVariableRef, value::Real;
         force::Bool = false)::Nothing</code></pre><p>Extend <code>JuMP.fix</code> to fix the value of an <code>InfiniteOpt</code> variable. Errors if  variable has a lower and/or an upper bound(s) unless <code>force = true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fix(vref, 3)

julia&gt; fix_value(vref)
3.0

julia&gt; fix(vref2, 2, force = true)

julia&gt; fix_value(vref2)
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL663-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.FixRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.FixRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.FixRef</code> to return the constraint reference of the fix constraint  associated with <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cref = FixRef(vref)
var = 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL724-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unfix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unfix-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unfix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.unfix(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <code>JuMP.unfix</code> to unfix <code>vref</code>. Errors if it is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; unfix(vref)

julia&gt; is_fixed(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL742-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.start_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.start_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.start_value(vref::UserDecisionVariableRef)::Union{Nothing, Float64}</code></pre><p>Extend <code>JuMP.start_value</code> to return starting value of <code>InfiniteOpt</code> variable if  it has one. Returns <code>nothing</code> otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; start_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL767-L778">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_start_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}" href="#JuMP.set_start_value-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_start_value(vref::UserDecisionVariableRef, value::Real)::Nothing</code></pre><p>Extend <code>JuMP.set_start_value</code> to specify the start value of <code>InfiniteOpt</code>  variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_start_value(vref, 1)

julia&gt; start_value(vref)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL787-L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.start_value_function-Tuple{Union{DerivativeRef, InfiniteVariableRef}}" href="#InfiniteOpt.start_value_function-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_value_function(vref::Union{InfiniteVariableRef, DerivativeRef})::Union{Nothing, Function}</code></pre><p>Return the function that is used to generate the start values of <code>vref</code> for particular support values. Returns <code>nothing</code> if no start behavior has been specified.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; start_value_function(vref)
my_start_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL509-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_start_value_function-Tuple{InfiniteVariableRef,Union{Function, Real}}" href="#InfiniteOpt.set_start_value_function-Tuple{InfiniteVariableRef,Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_start_value_function(vref::InfiniteVariableRef,
                         start::Union{Real, Function})::Nothing</code></pre><p>Set the start value function of <code>vref</code>. If <code>start::Real</code> then a function is generated to such that the start value will be <code>start</code> for the entire infinite domain. If <code>start::Function</code> then this function should map to a scalar start value given a support value arguments matching the format of the parameter elements in <code>parameter_refs(vref)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_start_value_function(vref, 1) # all start values will be 1

julia&gt; set_start_value_function(vref, my_func) # each value will be made via my_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL532-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.reset_start_value_function-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.reset_start_value_function-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.reset_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_start_value_function(vref::InfiniteVariableRef)::Nothing</code></pre><p>Remove the existing start value function and return to the default. Generally, this is triggered by deleting an infinite parameter that <code>vref</code> depends on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; reset_start_value_function(vref)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL567-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_binary(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <code>JuMP.is_binary</code> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is  binary.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL816-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.set_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_binary(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <code>JuMP.set_binary</code> to specify an <code>InfiniteOpt</code> variable as a binary  variable. Errors if <code>vref</code> is an integer variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_binary(vref)

julia&gt; is_binary(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL846-L859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.BinaryRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.BinaryRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.BinaryRef</code> to return a constraint reference to the constraint  constrainting <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL881-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unset_binary-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.unset_binary(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <code>JuMP.unset_binary</code> to unset <code>vref</code> as a binary variable. Errors if it is  not binary.</p><pre><code class="language-julia-repl">julia&gt; unset_binary(vref)

julia&gt; is_binary(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL899-L911">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_integer(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <code>JuMP.is_integer</code> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is  integer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL924-L935">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.set_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_integer(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <code>JuMP.set_integer</code> to specify an <code>InfiniteOpt</code> variable as a integer  variable. Errors if <code>vref</code> is an binary variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_integer(vref)

julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL957-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.IntegerRef-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.IntegerRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.IntegerRef</code> to return a constraint reference to the constraint  constrainting <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL992-L1003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unset_integer-Tuple{Union{DerivativeRef, FiniteVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.unset_integer(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <code>JuMP.unset_integer</code> to unset <code>vref</code> as an integer variable. Errors if it  is not an integer variable.</p><pre><code class="language-julia-repl">julia&gt; unset_integer(vref)

julia&gt; is_integer(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL1010-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{SemiInfiniteVariableRef}" href="#JuMP.lower_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(vref::SemiInfiniteVariableRef)::Float64</code></pre><p>Extend <code>JuMP.lower_bound</code> to return the lower bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL415-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.LowerBoundRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.LowerBoundRef</code> to extract a constraint reference for the lower bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = LowerBoundRef(vref)
var &gt;= 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL447-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{SemiInfiniteVariableRef}" href="#JuMP.has_upper_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <code>JuMP.has_upper_bound</code> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL465-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{SemiInfiniteVariableRef}" href="#JuMP.upper_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(vref::SemiInfiniteVariableRef)::Float64</code></pre><p>Extend <code>JuMP.upper_bound</code> to return the upper bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL481-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.UpperBoundRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.UpperBoundRef</code> to extract a constraint reference for the upper bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = UpperBoundRef(vref)
var &lt;= 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL513-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{SemiInfiniteVariableRef}" href="#JuMP.is_fixed-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_fixed(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <code>JuMP.is_fixed</code> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_fixed(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL531-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{SemiInfiniteVariableRef}" href="#JuMP.fix_value-Tuple{SemiInfiniteVariableRef}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix_value(vref::SemiInfiniteVariableRef)::Float64</code></pre><p>Extend <code>JuMP.fix_value</code> to return the fix value of the original infinite variable of <code>vref</code>. Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fix_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL547-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.FixRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.FixRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.FixRef</code> to return the constraint reference of the fix constraint associated with the original infinite variable of <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cref = FixRef(vref)
var == 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL579-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.start_value_function-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.start_value_function-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_value_function(vref::SemiInfiniteVariableRef)::Union{Nothing, Function}</code></pre><p>Return the function that is used to generate the start values of <code>vref</code> for particular support values. Returns <code>nothing</code> if no start behavior has been specified.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; start_value_func(vref)
my_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL603-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{SemiInfiniteVariableRef}" href="#JuMP.is_binary-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_binary(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <code>JuMP.is_binary</code> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is binary.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_binary(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL620-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.BinaryRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.BinaryRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.BinaryRef</code> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL648-L660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{SemiInfiniteVariableRef}" href="#JuMP.is_integer-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_integer(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <code>JuMP.is_integer</code> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is integer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL667-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.IntegerRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.IntegerRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <code>JuMP.IntegerRef</code> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL695-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(vref::InfiniteVariableRef)::Tuple</code></pre><p>Return the parameter references associated with the infinite variable <code>vref</code>. This is formatted as a Tuple of containing the parameter references as they inputted to define <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @variable(model, T, Infinite(t))
T(t)

julia&gt; parameter_refs(T)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL434-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(vref::SemiInfiniteVariableRef)::Tuple</code></pre><p>Return the infinite parameter references associated with the semi-infinite variable <code>vref</code>. This is formatted as a <code>Tuple</code> of containing the parameter references as they were inputted to define the untranscripted infinite variable except, the evaluated parameters are excluded.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(vref)
(t, [x[1], x[2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL317-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.parameter_list-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(vref::InfiniteVariableRef)::Vector{GeneralVariableRef}</code></pre><p>Return a vector of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL454-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.parameter_list-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(vref::SemiInfiniteVariableRef)::Vector{GeneralVariableRef}</code></pre><p>Return a vector of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL335-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(vref::InfiniteVariableRef)::VectorTuple</code></pre><p>Return the raw <a href="#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the  parameter references that <code>vref</code> depends on. This is primarily an internal method  where <a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>parameter_refs</code></a>  is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/infinite_variables.jl#LL422-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(vref::SemiInfiniteVariableRef)::VectorTuple</code></pre><p>Return the raw <a href="#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the  parameter references that <code>vref</code> depends on. This is primarily an internal method  where <a href="#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>parameter_refs</code></a>  is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL302-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_variable_ref(vref::PointVariableRef)::GeneralVariableRef</code></pre><p>Return the <code>InfiniteVariableRef</code> associated with the point variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @variable(model, T, Infinite(t))
T(t)

julia&gt; @variable(model, T0, Point(T, 0))
T0

julia&gt; infinite_variable_ref(T0)
T(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/point_variables.jl#LL332-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_variable_ref(vref::SemiInfiniteVariableRef)::GeneralVariableRef</code></pre><p>Return the infinite variable/derivative/parameter function reference associated  with the semi-infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_variable_ref(vref)
g(t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL269-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_values-Tuple{PointVariableRef}" href="#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.parameter_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_values(vref::PointVariableRef)::Tuple</code></pre><p>Return the support point associated with the point variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @variable(model, T, Infinite(t))
T(t)

julia&gt; @variable(model, T0, Point(T, 0))
T0

julia&gt; parameter_values(T0)
(0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/point_variables.jl#LL363-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.eval_supports-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.eval_supports-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_supports(vref::SemiInfiniteVariableRef)::Dict{Int, Float64}</code></pre><p>Return the evaluation supports associated with the semi-infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; eval_supports(vref)
Dict{Int64,Float64} with 1 entry:
  1 =&gt; 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/semi_infinite_variables.jl#LL285-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_values-Tuple{PointVariableRef}" href="#InfiniteOpt.raw_parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.raw_parameter_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_values(vref::PointVariableRef)::Vector{Float64}</code></pre><p>Return the raw support point values associated with the point variable <code>vref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/point_variables.jl#LL354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.relax_integrality-Tuple{InfiniteModel}" href="#JuMP.relax_integrality-Tuple{InfiniteModel}"><code>JuMP.relax_integrality</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.relax_integrality(model::InfiniteModel)::Function</code></pre><p>Modifies <code>model</code> to &quot;relax&quot; all binary and integrality constraints on variables. Specifically,</p><ul><li>Binary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval <span>$[0, 1]$</span>.</li><li>Integrality constraints are deleted without modifying variable bounds.</li><li>All other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.</li></ul><p>Returns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; undo_relax = relax_integrality(model);

julia&gt; print(model)
Min x + ∫{t ∈ [0, 10]}(y(t))
Subject to
 x ≥ 0.0
 y(t) ≥ 1.0
 x ≤ 1.0
 y(t) ≤ 10.0

julia&gt; undo_relax()

julia&gt; print(model)
Min x + ∫{t ∈ [0, 10]}(y(t))
Subject to
 y(t) ≥ 1.0
 y(t) ≤ 10.0
 y(t) integer
 x binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c8ebf38e092e41dd773677ff61a6b1c128a7115d/src/variable_basics.jl#LL1231-L1269">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../finite_parameter/">« Finite Parameters</a><a class="docs-footer-nextpage" href="../derivative/">Derivatives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 4 June 2021 22:42">Friday 4 June 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
