<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measures · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start Guide</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li class="is-active"><a class="tocitem" href>Measures</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#measure_basic_usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Theoretical-Abstraction"><span>Theoretical Abstraction</span></a></li><li><a class="tocitem" href="#Measure-Data-Generation"><span>Measure Data Generation</span></a></li><li><a class="tocitem" href="#Evaluation-Methods"><span>Evaluation Methods</span></a></li><li><a class="tocitem" href="#Expansion"><span>Expansion</span></a></li><li><a class="tocitem" href="#Semi-Infinite-Variables"><span>Semi-Infinite Variables</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#MeasureToolbox-Datatypes"><span>MeasureToolbox Datatypes</span></a></li><li><a class="tocitem" href="#MeasureToolbox-Methods"><span>MeasureToolbox Methods</span></a></li></ul></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Measures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/measure.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="measure_page"><a class="docs-heading-anchor" href="#measure_page">Measure Operators</a><a id="measure_page-1"></a><a class="docs-heading-anchor-permalink" href="#measure_page" title="Permalink"></a></h1><p>A guide and manual for the definition and use of measures in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Measure operators are objects that capture the evaluation of an expression with respect to parameters, which is a distinct feature of optimization problems with infinite decision spaces. In dynamic optimization measures can represent integral terms such as the total cost over time, and in stochastic optimization measures can represent integrals over the uncertain parameters, such as expectations. In <code>InfiniteOpt</code>, measures are general operators that can be uni-variate or  multi-variate. Natively we employ measure abstractions that employ discretization  schemes, which evaluate the expression at a set of points over the parameter space and approximates the measures based on the expression values at these points. However,  we support the use of alternative measure operator paradigms.</p><h2 id="measure_basic_usage"><a class="docs-heading-anchor" href="#measure_basic_usage">Basic Usage</a><a id="measure_basic_usage-1"></a><a class="docs-heading-anchor-permalink" href="#measure_basic_usage" title="Permalink"></a></h2><p>First, we consider a dynamic optimization problem with the time parameter <code>t</code> from 0 to 10. We also consider a state variable <code>y(t)</code> and a control variable <code>u(t)</code> that are parameterized by <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0, 5, 10])
t

julia&gt; @infinite_variable(model, y(t))
y(t)

julia&gt; @infinite_variable(model, u(t))
u(t)</code></pre><p>Now suppose we want to evaluate the integral <span>$\int_{2}^{8}y(t)^2 + u(t)^2 dt$</span>. We can construct a measure to represent this integral using the <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> function</p><pre><code class="language-julia-repl">julia&gt; mref1 = integral(y^2 + u^2, t, 2, 8)
∫{t ∈ [2, 8]}[y(t)² + u(t)²]</code></pre><p>The four positional arguments of <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> are the integrand expression,  the parameter of integration, the lower bound, and the upper bound, respectively.  Specifying the integrand expression and the parameter of integration is required. If the lower and upper bounds are not specified, then the integration will be over the entire domain, which is <span>$[0, 10]$</span> in this case.</p><p>The <code>integral</code> function uses trapezoid rule as the default discretization scheme for univariate parameters in finite <code>IntervalSet</code>s. In addition, the user can also  use quadrature methods for univariate parameters in all <code>IntervalSet</code>s by setting the keyword argument <code>eval_method</code> as <code>Quadrature()</code>:</p><pre><code class="language-julia-repl">julia&gt; mref2 = integral(y^2 + u^2, t, eval_method = Quadrature())
∫{t ∈ [0, 10]}[y(t)² + u(t)²]</code></pre><p>The <code>integral</code> function also allows for specifying other keyword arguments that  correspond to the chosen evaluation method. For example, when using  <a href="#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>FEGaussLobatto</code></a> as the evaluation method we can specify the number of  discretization points per finite element via <code>num_nodes</code>. </p><pre><code class="language-julia-repl">julia&gt; mref3 = ∫(y^2 + u^2, t, eval_method = FEGaussLobatto(), num_nodes = 3)
∫{t ∈ [0, 10]}[y(t)² + u(t)²]</code></pre><p>Notice here how we used <a href="#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>∫</code></a> in place of <code>integral</code> as a convenient wrapper.</p><p>Two other explicit measure type methods include <a href="#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a> for expectations  and <a href="#InfiniteOpt.MeasureToolbox.support_sum"><code>support_sum</code></a> for summing an expression over the support points of  selected infinite parameters. The syntax for these is analogous to that of <code>integral</code>  except that there are no lower/upper bounds. For example, we can define the following  expectation of a random expression:</p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel();

julia&gt; @infinite_parameter(m, ξ in Normal(), num_supports = 100);

julia&gt; @infinite_variable(m, x(ξ));

julia&gt; expect_x = expect(x^2, ξ)
𝔼{ξ}[x(ξ)²]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For integrals, expectations, and support sums involving moderate to large  expressions, the macro versions <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a>, <a href="#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a>, and  <a href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>@support_sum</code></a> should be used instead of their functional equivalents  for better performance.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For convenience in compact representation we can use <a href="#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>∫</code></a>, <a href="#InfiniteOpt.MeasureToolbox.@∫"><code>@∫</code></a>,  <a href="#InfiniteOpt.MeasureToolbox.𝔼"><code>𝔼</code></a>, and <a href="#InfiniteOpt.MeasureToolbox.@𝔼"><code>@𝔼</code></a> as wrappers for <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a>,  <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a>, <a href="#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a>, and <a href="#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a>, respectively.</p></div></div><p>Other measure paradigms can be implemented via <a href="#InfiniteOpt.measure"><code>measure</code></a> as described in  the sections further below.</p><p>Depending on the type of measures created, support points may be generated at the time of creating the measures. In these cases, the new support points will be added to the support list of the integrated parameter.</p><p>Once a measure is created, the evaluation of that measure is stored in a measure data object. Users can query the measure data object using the <a href="#InfiniteOpt.measure_data"><code>measure_data</code></a> function as follows</p><pre><code class="language-julia-repl">julia&gt; measure_data(mref2)
FunctionalDiscreteMeasureData{GeneralVariableRef,Float64,UniformGenerativeInfo}(t, getfield(InfiniteOpt.MeasureToolbox, Symbol(&quot;##5#6&quot;)){Int64}(3), 0, All, UniformGenerativeInfo([0.5], InternalGaussLobatto), InfiniteOpt.default_weight, 0.0, 10.0, false)</code></pre><p>Natively in <code>InfiniteOpt</code>, two types of measure data objects are used to store the measure data information depending on the nature of the measures created: <code>DiscreteMeasureData</code> and <code>FunctionalDiscreteMeasureData</code>. For more details on the measure data object,  refer to <a href="#Measure-Data-Generation">Measure Data Generation</a>.</p><p>Similarly, one can also query the expression the measure operates on using  <a href="#InfiniteOpt.measure_function"><code>measure_function</code></a>:</p><pre><code class="language-julia-repl">julia&gt; measure_function(mref3)
y(t)² + u(t)²</code></pre><p>In addition to <code>eval_method</code>, the <code>integral</code> function  also accepts <code>weight_func</code> as keyword argument, which dictates the weight function of the measure. Now suppose we want to create multiple measures that share the  same keyword argument values that are different from the defaults. We don&#39;t have  to input the keyword argument values every time we construct a new measure.  Instead, we can modify the default values of measure keyword arguments, and  construct measures using the new default values. To do that, we use the functions <a href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>set_uni_integral_defaults</code></a> and <a href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>set_multi_integral_defaults</code></a>. We  can in turn reset these via <a href="#InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults"><code>clear_uni_integral_defaults</code></a> and  <a href="#InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults"><code>clear_multi_integral_defaults</code></a>. Adding new keyword arguments will be  useful if users want to extend the measure functions with their custom  representation/evaluation schemes that need to take additional arguments somehow.  See <a href="../../extensions/#Extensions">Extensions</a> for more details.</p><p>Now we can add integrals to the constraints and objective functions in our model using these measures. For more detailed information, please review the information below.</p><h2 id="Theoretical-Abstraction"><a class="docs-heading-anchor" href="#Theoretical-Abstraction">Theoretical Abstraction</a><a id="Theoretical-Abstraction-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Abstraction" title="Permalink"></a></h2><p>In <code>InfiniteOpt</code>, measures denote operators <span>$M_\ell$</span> that operate on some infinite  expression <span>$y$</span> over the infinite domain <span>$\mathcal{D}_\ell$</span> associated with  the infinite parameter <span>$\ell$</span>:</p><p class="math-container">\[M_{\ell}y : \mathcal{D}_{-\ell} \mapsto \mathbb{R}^{n_y}\]</p><p>Such a paradigm can capture a wide variety of mathematical operators commonly  encountered in infinite-dimensional programming such as integrals, expectations,  risk measures, and chance constraints.</p><p>Currently, <code>InfiniteOpt</code> natively contains programmatic objects for measures that  can be represented as integrals of the form:</p><p class="math-container">\[\int_{\tau \in \mathcal{T}} f(\tau)w(\tau) d\tau\]</p><p>where <span>$\tau$</span> is a (possibly multivariate) infinite parameter, <span>$f(\tau)$</span> is an  expression parameterized by <span>$\tau$</span>, <span>$w(\tau)$</span> is a weight function, and  <span>$\mathcal{T}$</span> is a subset of the domain of <span>$\tau$</span>. The measures approximate  the integrals by taking a discretization scheme</p><p class="math-container">\[\int_{\tau \in \mathcal{T}} f(\tau)w(\tau) d\tau \approx \sum_{i=1}^N \alpha_i f(\tau_i) w(\tau_i)\]</p><p>where <span>$\tau_i$</span> are the grid points where the expression <span>$f(\tau)$</span> is evaluated, and <span>$N$</span> is the total number of points taken.</p><p>This is the abstraction behind both <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> and  <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a> which are the native measure data types  in InfiniteOpt. The <a href="#Measure-Data-Generation">Measure Data Generation</a> section below details how  these can be implemented to enable schemes that fit this mathematical paradigm, but  lie out of the realm of the supported features behind <code>integral</code>, <code>expect</code>, and  <code>support_sum</code>.</p><p>More complex measure paradigms can also be implemented by creating concrete  subtype of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> as detailed in <a href="../../extensions/#Measure-Data">Measure Data</a> Section  on our extensions page.</p><h2 id="Measure-Data-Generation"><a class="docs-heading-anchor" href="#Measure-Data-Generation">Measure Data Generation</a><a id="Measure-Data-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-Data-Generation" title="Permalink"></a></h2><p>The general <a href="#InfiniteOpt.measure"><code>measure</code></a> function takes two arguments: the argument expression and a measure data object that contains the details of the measure representation. Measure data objects can be constructed using <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, where the parameter of integration, the coefficients <span>$\alpha_i$</span>, and the support points need to be defined explicitly. For example, if we want to evaluate a function at each integer time point between 0 and 10, we can construct the following measure data object to record this discretization scheme:</p><pre><code class="language-julia-repl">julia&gt; md_t = DiscreteMeasureData(t, ones(10), [i for i in 1:10]);</code></pre><p>The arguments of <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> are parameter, coefficients, and supports. The default weight function is <span>$w(\tau) = 1$</span> for any <span>$\tau$</span>, which can be overwritten by the keyword argument <code>weight_function</code>. The <code>weight_function</code> should take a function that returns a number for any value that is well defined for the integrated infinite parameter. The data type is <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, which is a subtype of the abstract data type <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><p>With <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, a measure can be generated in a custom and quick manner. For example, using the measure data above, we can define a measure for <span>$y^2$</span> as follows:</p><pre><code class="language-julia-repl">julia&gt; mref = measure(y^2, md_t)
measure{t}[y(t)²]</code></pre><p>In the same way, we can define measure data for multi-variate infinite parameters. For example, we can define a discretization scheme for a 2D position parameter <span>$x \in [0, 1] \times [0, 1]$</span> as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:2] in [0, 1])
2-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]

julia&gt; md_x = DiscreteMeasureData(x, 0.25 * ones(4), [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]]);</code></pre><p>where <code>md_x</code> cuts the domain into four 0.5-by-0.5 squares, and evaluates the integrand on the center of these squares. Note that for multivariate parameters,  each support point should be an <code>AbstractArray</code> that stores the value at each dimension.</p><p>In addition to the intuitive [<code>DiscreteMeasureData</code>], another type of measure data  object is <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. This type captures measure data where the support points are not known at the time of measure data creation. Instead of  storing the specific support and coefficient values, <code>FunctionalDiscreteMeasureData</code> stores the minimum number of supports required for the measure, and a coefficient function that maps supports to coefficients. When the measure is built on a <code>FunctionalDiscreteMeasureData</code>  is evaluated (expanded), supports will be generated based on the functions stored in  the data object. The method of support generation is recorded as a <code>label</code> in the measure object. </p><p>For example, suppose we want to uniformly generate at least 20 Monte Carlo samples  over the interval that <code>t</code> is in. A build-in label <code>UniformGrid</code> can be used to  signify the use of this method. A <code>FunctionalDiscreteMeasureData</code> can be created as follows:</p><pre><code class="language-julia-repl">julia&gt; coeff_f(supports) = [(10 - 0) / length(supports) for i in supports]
coeff_f (generic function with 1 method)

julia&gt; fmd_t = FunctionalDiscreteMeasureData(t, coeff_f, 20, UniformGrid);</code></pre><p>For more details see <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. </p><p>Our higher-level measure methods, such as <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a>, do not require  explicit construction of the measure data object and instead serve as wrappers  that construct the appropriate data object and then call <a href="#InfiniteOpt.measure"><code>measure</code></a>.</p><h2 id="Evaluation-Methods"><a class="docs-heading-anchor" href="#Evaluation-Methods">Evaluation Methods</a><a id="Evaluation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Methods" title="Permalink"></a></h2><p>The <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> function calls <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> under the hood to construct the measure data object. <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> takes as positional arguments the integrated parameter, lower bound, upper bound, and method, and returns a measure data object of type <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><p><a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> applies multiple dispatch to encode different support generation methods depending on the input <code>eval_method</code>. Each dispatch is distinguished by  the <code>method</code>, which takes a concrete subtype of <code>AbstractIntegralMethod</code>.  Each dispatch of <code>generate_integral_data</code> implements the specified method and returns the resulting measure data, which will be used by <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a> to create the measure. A table of available <code>method</code> options in our package is listed below. Each method is limited on the dimension of parameter and/or the type of set that it can apply for. For the details of what each method type means, refer to the corresponding docstrings.</p><table><tr><th style="text-align: center">Evaluation Method</th><th style="text-align: center">Uni/Multi-Variate?</th><th style="text-align: center">Weight Function</th><th style="text-align: center">Set Type</th></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic()</code></a></td><td style="text-align: center">Both</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Any</td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>UniTrapezoid()</code></a></td><td style="text-align: center">Both</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center"><a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>UniIndepMCSampling()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>Quadrature()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center"><a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>GaussLegendre()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussRadau"><code>GaussRadau()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussJacobi"><code>GaussJacobi(α, β)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$(1-x)^\alpha (1+x)^\beta$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>GaussLobatto()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>FEGaussLobatto()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(1)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$\frac{1}{\sqrt{1-x^2}}$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(2)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$\sqrt{1-x^2}$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(3)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$\sqrt{(1+x)/(1-x)}$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(4)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$\sqrt{(1-x)/(1+x)}$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>GaussLaguerre()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$e^{-x}$</span></td><td style="text-align: center">Semi-infinite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>GaussHermite()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$e^{-x^2}$</span></td><td style="text-align: center">Infinite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling()</code></a></td><td style="text-align: center">Multivariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>MultiIndepMCSampling()</code></a></td><td style="text-align: center">Multivariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr></table><p>The eval method <a href="#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>FEGaussLobatto</code></a> creates finite elements by decomposing over the  supports that have been added to the integral parameter and then approximates the  integral over each finite element via Lobatto quadrature using num_nodes.  All other Gauss quadrature methods do not incorporate any existing supports nor  do they decompose the integral into finite elements, but instead generate their  quadrature node points over the entire integral domain. See the  <a href="#A-Note-on-Support-Management">A Note on Support Management</a> Section for more information. This method  will take in the user supports, and create generative supports along each interval  and match them with corresponding coefficients. Here is a depiction of such what  <code>FEGaussLobatto</code> does. </p><p><img src="..\\assets\\FEGaussLobatto.png" alt="Image"/></p><p><span>$\int_{x_1}^{x_3} f(x) dx = \int_{x_1}^{x_2} f(x) dx + \int_{x_2}^{x_3} f(x) dx$</span></p><p><span>$\approx \sum_{i=1}^{n} \alpha_{a,i} f(\tau_{a,i}) + \sum_{i=1}^{n} \alpha_{b,i} f(\tau_{b,i})$</span></p><p><span>$= \sum_{i=1}^{n} (\alpha_{a,i} f(\tau_{a,i}) + \alpha_{b,i} f(\tau_{b,i}))$</span></p><p>where <span>$\tau_{a,i}$</span> and <span>$\tau_{b,i}$</span> are the discrete nodes for the two intervals </p><p>and <span>$\alpha_{a,i}$</span> and <span>$\alpha_{b,i}$</span> are the coefficients.</p><pre><code class="language-julia-repl">julia&gt; mref_lob = integral(y^2 + u^2, t, num_nodes = 3, eval_method = FEGaussLobatto())
∫{t ∈ [0, 10]}[y(t)² + u(t)²]

julia&gt; expand(mref_lob)
0.8333333333333333 y(0)² + 0.8333333333333333 u(0)² + 3.333333333333333 y(2.5)² + 3.333333333333333 u(2.5)² + 1.6666666666666665 y(5)² + 1.6666666666666665 u(5)² + 3.333333333333333 y(7.5)² + 3.333333333333333 u(7.5)² + 0.8333333333333333 y(10)² + 0.8333333333333333 u(10)²
</code></pre><p>We set <code>num_nodes = 3</code> to define the number of nodes (supports) that will be used  at each finite element for the integral approximation. Note that this is inclusive  of the finite element supports, so the number of generative (internal) supports  added to each finite element is <code>num_nodes - 2</code>.  </p><p>In summary, we natively support trapezoid rule, Gaussian quadrature methods for  univariate parameters, and Monte Carlo sampling for both univariate and  multivariate infinite parameters. For extension purposes, users may define their  own <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> to encode custom evaluation methods. See  <a href="../../extensions/#Extensions">Extensions</a> for more details.</p><h3 id="A-Note-on-Support-Management"><a class="docs-heading-anchor" href="#A-Note-on-Support-Management">A Note on Support Management</a><a id="A-Note-on-Support-Management-1"></a><a class="docs-heading-anchor-permalink" href="#A-Note-on-Support-Management" title="Permalink"></a></h3><p>There is a difference in how supports are considered using <code>UniTrapezoid()</code>/<code>FEGaussLobatto()</code> vs. the other schemes. Namely, the other schemes will NOT incorporate other supports  specified elsewhere in the model. Consider the following example with 3 equidistant  supports and an integral objective function that uses <code>UniTrapezoid()</code> (the default):</p><pre><code class="language-julia"># Create a model, with one variable and an infinite parameter with a given number of supports
m = InfiniteModel()
@infinite_parameter(m, t in [0, 2], num_supports = 3)
@infinite_variable(m, u(t))

# Create an objective function with the default trapezoid integration
@objective(m, Min, integral(u^2, t))

# Get the transcribed model to check how the supports are taken into account
build_optimizer_model!(m)
trans_m = optimizer_model(m);</code></pre><p>If we look at how many supports there are, how the variable <code>u</code> is transcribed,  and how the objective function of the transcribed model looks like, we notice that  the same supports are used in both the objective function and the transcribed  variable:</p><pre><code class="language-julia-repl">julia&gt; supports(t) 
3-element Array{Float64,1}:
 0.0
 1.0
 2.0

julia&gt; transcription_variable(u)  
3-element Array{VariableRef,1}:
 u(support: 1)
 u(support: 2)
 u(support: 3)

julia&gt; objective_function(trans_m) 
0.5 u(support: 1)² + u(support: 2)² + 0.5 u(support: 3)²</code></pre><p>Thus, the integral incorporates the 3 supports generated outside of the <code>integral</code>  declaration.</p><p>Then we readjust the model to use Gauss-Legendre quadrature via <code>GaussLegendre()</code>  that uses 2 quadrature nodes:</p><pre><code class="language-julia"># Set the new objective and update the TranscriptionModel
set_objective_function(m, integral(u^2, t, eval_method = GaussLegendre(), num_nodes = 2))
build_optimizer_model!(m)
trans_m = optimizer_model(m);</code></pre><p>Now let&#39;s look again at the number of supports, the transcription of <code>u</code>, and the  new objective function:</p><pre><code class="language-julia-repl">julia&gt; supports(t) 
5-element Array{Float64,1}:
 0.0
 0.42264973081
 1.0
 1.57735026919
 2.0

julia&gt; transcription_variable(u)  
5-element Array{VariableRef,1}:
 u(support: 1)
 u(support: 2)
 u(support: 3)
 u(support: 4)
 u(support: 5)

julia&gt; objective_function(trans_m) 
u(support: 2)² + u(support: 4)²</code></pre><p>The supports used in the objective function are different from the supports used  in the transcription of <code>u</code>. The integral objective function has been transcribed  using the 2 quadrature supports, but does not include the other supports since  they cannot be incorporated into the Gaussian quadrature approximation. Whereas, <code>u</code> is defined over all the supports and thus certain realizations of <code>u</code> will  excluded from the objective function which will affect the behavior of the  optimization and lead to unexpected results.</p><p>However, this behavior is avoided if we let the integral add the supports and  not add supports elsewhere (for convenience we&#39;ll use <code>set_uni_integral_defaults</code>):</p><pre><code class="language-julia"># Define a new model, parameter, and variable
m = InfiniteModel()
@infinite_parameter(m, t in [0, 2])
@infinite_variable(m, u(t))

# Update the integral default keyword arguments for convenience 
set_uni_integral_defaults(eval_method = GaussLegendre(), num_nodes = 2)

# Set the objective with our desired integral
@objective(m, Min, integral(u^2, t))

# Build the transcribed model 
build_optimizer_model!(m)
trans_m = optimizer_model(m);</code></pre><p>Then we get the supports are consistent for <code>u</code> and the integral:</p><pre><code class="language-julia-repl">julia&gt; supports(t) 
2-element Array{Float64,1}:
 0.42264973081
 1.57735026919

julia&gt; transcription_variable(u)  
2-element Array{VariableRef,1}:
 u(support: 1)
 u(support: 2)

julia&gt; objective_function(trans_m) 
u(support: 1)² + u(support: 2)²</code></pre><p>Therefore, using quadratures other than <code>UniTrapezoid()</code> or <code>FEGaussLobatto()</code>  requires careful analysis if there are user-defined supports in the problem. </p><h2 id="Expansion"><a class="docs-heading-anchor" href="#Expansion">Expansion</a><a id="Expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Expansion" title="Permalink"></a></h2><p>In a model, each measure records the integrand expression and an evaluation scheme that details the discretization scheme to approximate the integral. The model will not expand the measures until the transcription stage, at which a <code>JuMP.AbstractJuMPScalar</code> is created for each measure to represent how the measure is modeled in a transcription model based on the stored discretization scheme (see <a href="../transcribe/#transcription_docs">Model Transcription</a> for details on transcription). Additional point variables will be created in the expansion process if the measure is evaluated at infinite parameter points that do not have corresponding point variables yet.</p><p>Sometimes for extension purposes, one might want to expand a specific measure before reaching the transcription stage. Alternatively, one might want to use custom reformulation instead of the transcription encoded in this package, in which expanding measures will also be useful. This can be done using the <a href="#InfiniteOpt.expand"><code>expand</code></a> function, which takes a <a href="#InfiniteOpt.MeasureRef"><code>MeasureRef</code></a> object and returns a <code>JuMP.AbstractJuMPScalar</code> based on the <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>. For example, suppose we want to integrate <span>$y^2$</span> in <span>$t$</span>, with two supports <span>$t = 2.5$</span> and <span>$t = 7.5$</span>. We can set up and expand this measure as follows:</p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [5, 5], [2.5, 7.5]);

julia&gt; mref4 = measure(y^2, tdata)
measure{t}[y(t)²]

julia&gt; expanded_measure = expand(mref4)
5 y(2.5)² + 5 y(7.5)²

julia&gt; typeof(expanded_measure)
GenericQuadExpr{Float64,GeneralVariableRef}</code></pre><p>In the expand call, two point variables, <code>y(2.5)</code> and <code>y(7.5)</code>, are created because they are not defined in the model before the expand call. One can use the <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a> function to expand all measures in a model, which simply applies the <a href="#InfiniteOpt.expand"><code>expand</code></a> to all measures stored in the model.</p><h2 id="Semi-Infinite-Variables"><a class="docs-heading-anchor" href="#Semi-Infinite-Variables">Semi-Infinite Variables</a><a id="Semi-Infinite-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-Infinite-Variables" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Previous versions of <code>InfiniteOpt</code> referred to semi-infinite variables as  &quot;reduced infinite variables&quot;. </p></div></div><p>Expanding measures that cover a subset of infinite parameter dependencies present  in an expression will introduce semi-infinite variables to the model. To see what this means, suppose we have an infinite variable that is parameterized by multiple infinite parameters defined as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, T(x, t))
T(x, t)</code></pre><p>Now say we want to integrate <code>T</code> over <code>t</code>. We can define a measure for the integral similar to how we have defined other measures:</p><pre><code class="language-julia-repl">julia&gt; mref5 = measure(T, tdata)
measure{t}[T(x, t)]</code></pre><p>Now if we expand this measure, the measure data object <code>tdata</code> records the supports for <code>t</code>, but no supports for <code>x</code> because <code>T</code> is not evaluated over <code>x</code> in this measure. Therefore, point variables cannot be defined in the measure expansion.</p><p>Instead of point variables, each new variable in the measure expansion will be represented using semi-infinite variables. Semi-infinite variables are reduced from their original infinite variables in that they are parameterized by less infinite parameters. In the example above, in the expansion each semi-infinite variable for <code>T</code> should only be parameterized by <code>x</code> since the value of <code>t</code> is fixed. The expanded measure now looks like this:</p><pre><code class="language-julia-repl">julia&gt; expanded_measure = expand(mref5)
5 T([x[1], x[2]], 2.5) + 5 T([x[1], x[2]], 7.5)</code></pre><p>where the expanded measure is a <code>JuMP.GenericAffExpr</code> that takes in its terms <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>s pointing to <a href="#InfiniteOpt.SemiInfiniteVariable"><code>SemiInfiniteVariable</code></a>s created on the fly. <a href="#InfiniteOpt.SemiInfiniteVariable"><code>SemiInfiniteVariable</code></a> refers to the information of the semi-infinite variable stored in its model. The semi-infinite variable records a reference for its original infinite variable, and the value of the fixed infinite parameter. One can query this information using <a href="../expression/#InfiniteOpt.infinite_variable_ref-Tuple{GeneralVariableRef}"><code>infinite_variable_ref</code></a> and <a href="../expression/#InfiniteOpt.eval_supports-Tuple{GeneralVariableRef}"><code>eval_supports</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; T1 = first(keys(expanded_measure.terms))
T([x[1], x[2]], 2.5)

julia&gt; infinite_variable_ref(T1)
T(x, t)

julia&gt; eval_supports(T1)
Dict{Int64,Float64} with 1 entry:
  3 =&gt; 2.5</code></pre><p>All the <code>JuMP</code> functions extended for infinite variables are also extended for semi-infinite variables, e.g. <a href="#JuMP.lower_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.lower_bound</code></a>.</p><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef,Array{#s37,1} where #s37&lt;:Real,Array{#s9,1} where #s9&lt;:Real}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Array{#s37,1} where #s37&lt;:Real,Array{#s9,1} where #s9&lt;:(AbstractArray{#s5,N} where N where #s5&lt;:Real)}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef,Function,Int64,Type{#s37} where #s37&lt;:AbstractSupportLabel}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Function,Int64,Type{#s37} where #s37&lt;:AbstractSupportLabel}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a></li><li><a href="#InfiniteOpt.MeasureData"><code>InfiniteOpt.MeasureData</code></a></li><li><a href="#InfiniteOpt.MeasureIndex"><code>InfiniteOpt.MeasureIndex</code></a></li><li><a href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a></li><li><a href="#InfiniteOpt.SemiInfiniteVariable"><code>InfiniteOpt.SemiInfiniteVariable</code></a></li><li><a href="#InfiniteOpt.SemiInfiniteVariableIndex"><code>InfiniteOpt.SemiInfiniteVariableIndex</code></a></li><li><a href="#InfiniteOpt.SemiInfiniteVariableRef"><code>InfiniteOpt.SemiInfiniteVariableRef</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractMeasureData" href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractMeasureData</code></pre><p>An abstract type to define data for measures to define the behavior of <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL886-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData" href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData{P &lt;: Union{JuMP.AbstractVariableRef,
                    Vector{&lt;:JuMP.AbstractVariableRef}},
                    N, B &lt;: Union{Float64, Vector{Float64}}
                    } &lt;: AbstractMeasureData</code></pre><p>A DataType for immutable measure abstraction data where the abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>. The supports and coefficients are immutable (i.e., they will not change even if supports are changed for the underlying infinite parameter.) This type can be used for both 1-dimensional and multi-dimensional measures.</p><p><strong>Fields</strong></p><ul><li><code>parameter_refs::P</code>: The infinite parameter(s) over which the integration occurs.                      These can be comprised of multiple independent parameters,                      but dependent parameters cannot be mixed with other types.</li><li><code>coefficients::Vector{Float64}</code>: Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Array{Float64, N}</code>: Supports points <span>$\tau_i$</span>. This is a <code>Vector</code>                                if only one parameter is given, otherwise it is                                a <code>Matrix</code> where the supports are stored column-wise.</li><li><code>label::DataType</code>: Label for the support points <span>$\tau_i$</span> when stored in the                  infinite parameter(s), stemming from <a href="../sets/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</li><li><code>weight_function::Function</code>: Weighting function <span>$w$</span> must map an individual                              support value to a <code>Real</code> scalar value.</li><li><code>lower_bounds::B</code>: Lower bound in accordance with <span>$T$</span>, this denotes the                   intended interval of the measure and should be <code>NaN</code> if ignored</li><li><code>upper_bounds::B</code>: Same as above but the upper bound.</li><li><code>is_expect::Bool</code>: Is this data associated with an expectation call?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL894-L924">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData" href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionalDiscreteMeasureData{P &lt;: Union{JuMP.AbstractVariableRef,
                              Vector{&lt;:JuMP.AbstractVariableRef}},
                              B &lt;: Union{Float64, Vector{Float64}},
                              I &lt;: AbstractGenerativeInfo
                              } &lt;: AbstractMeasureData</code></pre><p>A DataType for mutable measure abstraction data where the abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>. This abstraction is equivalent to that of <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, but the difference is that the supports are not fully known at the time of measure creation. Thus, functions are stored that will be used to generate the concrete support points <span>$\tau_i$</span> and their coefficients <span>$\alpha_i$</span> when the measure is evaluated (expanded). These supports are identified/generated in accordance with the <code>label</code> with a gaurantee that at least <code>num_supports</code> are generated. For example, if <code>label = MCSample</code> and <code>num_supports = 100</code> then the measure will use all of the supports stored in the <code>parameter_refs</code> with the label <code>MCSample</code> and will ensure there are at least 100 are generated. This type can be used for both 1-dimensional and multi-dimensional measures.</p><p>For 1-dimensional measures over independent infinite parameters, the  <code>generative_supp_info</code> specifies the info needed to make generative supports based  on those with that exist with <code>label</code>. Note that only 1 kind of generative  supports are allowed for each infinite parameter.</p><p><strong>Fields</strong></p><ul><li><code>parameter_refs::P</code>: The infinite parameter(s) over which the integration occurs.                    These can be comprised of multiple independent parameters,                    but dependent parameters cannot be mixed with other types.</li><li><code>coeff_function::Function</code>: Coefficient generation function making <span>$\alpha_i$</span>                             for the above measure abstraction. It should take                             all the supports as input (formatted as an Array)                             and return the corresponding vector of coefficients.</li><li><code>min_num_supports::Int</code>: Specifies the minimum number of supports <span>$\tau_i$</span>                      desired in association with <code>parameter_refs</code> and <code>label</code>.</li><li><code>label::DataType</code>: Label for the support points <span>$\tau_i$</span> which are/will be                  stored in the infinite parameter(s), stemming from <a href="../sets/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</li><li><code>generative_supp_info::I</code>: Information needed to generate supports based on other   existing ones.</li><li><code>weight_function::Function</code>: Weighting function <span>$w$</span> must map an individual                             support value to a <code>Real</code> scalar value.</li><li><code>lower_bounds::B</code>: Lower bounds in accordance with <span>$T$</span>, this denotes the                 intended interval of the measure and should be <code>NaN</code> if ignored</li><li><code>upper_bounds::B</code>: Same as above but the upper bounds.</li><li><code>is_expect::Bool</code>: Is this data associated with an expectation call?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL962-L1008">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Measure" href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Measure{T &lt;: JuMP.AbstractJuMPScalar, V &lt;: AbstractMeasureData}</code></pre><p>A <code>DataType</code> for measure abstractions. The abstraction is determined by <code>data</code> and is enacted on <code>func</code> when the measure is evaluated (expended).</p><p><strong>Fields</strong></p><ul><li><code>func::T</code> The <code>InfiniteOpt</code> expression to be measured.</li><li><code>data::V</code> Data of the abstraction as described in a <code>AbstractMeasureData</code>           concrete subtype.</li><li><code>object_nums::Vector{Int}</code>: The parameter object numbers of the evaluated                             measure expression (i.e., the object numbers of                             <code>func</code> excluding those that belong to <code>data</code>).</li><li><code>parameter_nums::Vector{Int}</code>: The parameter numbers that parameterize the                                evaluated measure expression. (i.e., the                                parameter numbers of <code>func</code> excluding those                                that belong to <code>data</code>).</li><li><code>constant_func::Bool</code>: Indicates if <code>func</code> is not parameterized by the infinite                        parameters in <code>data</code>. (i.e., do the object numbers of                        <code>func</code> and <code>data</code> have no intersection?) This is useful                        to enable analytic evaluations if possible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL1068-L1089">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureIndex" href="#InfiniteOpt.MeasureIndex"><code>InfiniteOpt.MeasureIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureData" href="#InfiniteOpt.MeasureData"><code>InfiniteOpt.MeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureData &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing <a href="#InfiniteOpt.Measure"><code>Measure</code></a>s and their data.</p><p><strong>Fields</strong></p><ul><li><code>measure::Measure</code>: The measure structure.</li><li><code>name::String</code>: The base name used for printing <code>name(meas_expr d(par))</code>.</li><li><code>measure_indices::Vector{MeasureIndex}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{ConstraintIndex}</code>: Indices of dependent constraints.</li><li><code>derivative_indices::Vector{DerivativeIndex}</code>: Indices of dependent derivatives.</li><li><code>in_objective::Bool</code>: Is this used in objective?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL1098-L1110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureRef" href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for referring to measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::MeasureIndex</code>: Index of the measure in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL1571-L1579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.SemiInfiniteVariable" href="#InfiniteOpt.SemiInfiniteVariable"><code>InfiniteOpt.SemiInfiniteVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemiInfiniteVariable{I &lt;: GeneralVariableRef} &lt;: InfOptVariable</code></pre><p>A <code>DataType</code> for storing semi-infinite variables which partially support an infinite variable.</p><p><strong>Fields</strong></p><ul><li><code>infinite_variable_ref::I</code>: The original infinite/derivvative variable.</li><li><code>eval_supports::Dict{Int, Float64}</code>: The original parameter tuple linear indices                                    to the evaluation supports.</li><li><code>parameter_nums::Vector{Int}</code>: The parameter numbers associated with the evaluated                                <code>parameter_refs</code>.</li><li><code>object_nums::Vector{Int}</code>: The parameter object numbers associated with the                             evaluated <code>parameter_refs</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL752-L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.SemiInfiniteVariableIndex" href="#InfiniteOpt.SemiInfiniteVariableIndex"><code>InfiniteOpt.SemiInfiniteVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemiInfiniteVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.SemiInfiniteVariable"><code>SemiInfiniteVariable</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.SemiInfiniteVariableRef" href="#InfiniteOpt.SemiInfiniteVariableRef"><code>InfiniteOpt.SemiInfiniteVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SemiInfiniteVariableRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::SemiInfiniteVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/datatypes.jl#LL1541-L1551">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.@measure"><code>InfiniteOpt.@measure</code></a></li><li><a href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a></li><li><a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.add_measure_variable</code></a></li><li><a href="#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}"><code>InfiniteOpt.add_supports_to_parameters</code></a></li><li><a href="#InfiniteOpt.all_measures"><code>InfiniteOpt.all_measures</code></a></li><li><a href="#InfiniteOpt.analytic_expansion"><code>InfiniteOpt.analytic_expansion</code></a></li><li><a href="#InfiniteOpt.build_measure"><code>InfiniteOpt.build_measure</code></a></li><li><a href="#InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficient_function</code></a></li><li><a href="#InfiniteOpt.coefficients-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficients</code></a></li><li><a href="#InfiniteOpt.default_weight"><code>InfiniteOpt.default_weight</code></a></li><li><a href="#InfiniteOpt.delete_internal_semi_infinite_variable"><code>InfiniteOpt.delete_internal_semi_infinite_variable</code></a></li><li><a href="#InfiniteOpt.delete_semi_infinite_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.delete_semi_infinite_variable</code></a></li><li><a href="#InfiniteOpt.eval_supports-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a></li><li><a href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a></li><li><a href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a></li><li><a href="#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a></li><li><a href="#InfiniteOpt.expand_measures"><code>InfiniteOpt.expand_measures</code></a></li><li><a href="#InfiniteOpt.generative_support_info-Tuple{AbstractMeasureData}"><code>InfiniteOpt.generative_support_info</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.internal_semi_infinite_variable"><code>InfiniteOpt.internal_semi_infinite_variable</code></a></li><li><a href="#InfiniteOpt.is_analytic"><code>InfiniteOpt.is_analytic</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.make_point_variable_ref"><code>InfiniteOpt.make_point_variable_ref</code></a></li><li><a href="#InfiniteOpt.make_semi_infinite_variable_ref"><code>InfiniteOpt.make_semi_infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.measure"><code>InfiniteOpt.measure</code></a></li><li><a href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a></li><li><a href="#InfiniteOpt.measure_data_in_finite_var_bounds-Tuple{AbstractMeasureData,ParameterBounds}"><code>InfiniteOpt.measure_data_in_finite_var_bounds</code></a></li><li><a href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a></li><li><a href="#InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.min_num_supports</code></a></li><li><a href="#InfiniteOpt.num_measures"><code>InfiniteOpt.num_measures</code></a></li><li><a href="#InfiniteOpt.num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.num_supports</code></a></li><li><a href="#InfiniteOpt.parameter_list-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{MeasureRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.raw_parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a></li><li><a href="#InfiniteOpt.start_value_function-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.start_value_function</code></a></li><li><a href="#InfiniteOpt.support_label-Tuple{AbstractMeasureData}"><code>InfiniteOpt.support_label</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#InfiniteOpt.weight_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.weight_function</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.add_variable-Tuple{InfiniteModel,SemiInfiniteVariable,String}"><code>JuMP.add_variable</code></a></li><li><a href="#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.fix_value-Tuple{SemiInfiniteVariableRef}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.is_binary-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_fixed-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_integer-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.lower_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.lower_bound-Tuple{AbstractMeasureData}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.set_name-Tuple{SemiInfiniteVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.upper_bound-Tuple{AbstractMeasureData}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.upper_bound</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.default_weight" href="#InfiniteOpt.default_weight"><code>InfiniteOpt.default_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_weight(t) = 1</code></pre><p>Default weight function for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> and <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Returns 1 regardless of the input value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef,Array{#s37,1} where #s37&lt;:Real,Array{#s9,1} where #s9&lt;:Real}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef,Array{#s37,1} where #s37&lt;:Real,Array{#s9,1} where #s9&lt;:Real}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData(pref::GeneralVariableRef,
    coefficients::Vector{&lt;:Real},
    supports::Vector{&lt;:Real};
    [label::Type{&lt;:AbstractSupportLabel} = generate_unique_label(),
    weight_function::Function = [`default_weight`](@ref),
    lower_bound::Real = NaN,
    upper_bound::Real = NaN,
    is_expect::Bool = false]
    )::DiscreteMeasureData</code></pre><p>Returns a 1-dimensional <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds or an unequal number of supports and coefficients are given. Note that by default a unique <code>label</code> is generated via <code>generate_unique_label</code> to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2])
DiscreteMeasureData{GeneralVariableRef,1,Float64}(pref, [0.5, 0.5], [1.0, 2.0], UniqueMeasure{Symbol(&quot;##373&quot;)}, default_weight, NaN, NaN, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL110-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Array{#s37,1} where #s37&lt;:Real,Array{#s9,1} where #s9&lt;:(AbstractArray{#s5,N} where N where #s5&lt;:Real)}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Array{#s37,1} where #s37&lt;:Real,Array{#s9,1} where #s9&lt;:(AbstractArray{#s5,N} where N where #s5&lt;:Real)}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData(prefs::AbstractArray{GeneralVariableRef},
    coefficients::Vector{&lt;:Real},
    supports::Vector{&lt;:AbstractArray{&lt;:Real}};
    label::Type{&lt;:AbstractSupportLabel} = generate_unique_label(),
    weight_function::Function = [`default_weight`](@ref),
    lower_bounds::AbstractArray{&lt;:Real} = [NaN...],
    upper_bounds::AbstractArray{&lt;:Real} = [NaN...],
    is_expect::Bool = false
    )::DiscreteMeasureData</code></pre><p>Returns a <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for <code>parameter_refs</code>. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or if mixed infinite parameter types are given. Note that by default a unique <code>label</code> is generated via <code>generate_unique_label</code> to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]]);

julia&gt; typeof(data)
DiscreteMeasureData{Array{GeneralVariableRef,1},2,Array{Float64,1}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL228-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef,Function,Int64,Type{#s37} where #s37&lt;:AbstractSupportLabel}" href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef,Function,Int64,Type{#s37} where #s37&lt;:AbstractSupportLabel}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FunctionalDiscreteMeasureData(pref::GeneralVariableRef,
    coeff_func::Function,
    min_num_supports::Int,
    label::Type{&lt;:AbstractSupportLabel};
    [weight_function::Function = [`default_weight`](@ref),
    lower_bound::Real = NaN,
    upper_bound::Real = NaN,
    is_expect::Bool = false,
    generative_support_info::AbstractGenerativeInfo = NoGenerativeSupports()]
    )::FunctionalDiscreteMeasureData</code></pre><p>Returns a 1-dimensional <code>FunctionalDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Errors if <code>pref</code> is not an infinite parameter. Built-in choices for <code>label</code> include:</p><ul><li><code>All</code>: Use all of the supports stored in <code>pref</code></li><li><code>MCSample</code>: Use Monte Carlo samples associated with <code>pref</code></li><li><code>WeightedSample</code>: Use weighted Monte Carlo samples associated with <code>pref</code></li><li><code>UniformGrid</code>: Use uniform grid points associated with <code>pref</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = FunctionalDiscreteMeasureData(pref, my_func, 20, UniformGrid)
FunctionalDiscreteMeasureData{GeneralVariableRef,Float64,NoGenerativeSupports}(pref, my_func, 20, UniformGrid, NoGenerativeSupports(), default_weight, NaN, NaN, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL286-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Function,Int64,Type{#s37} where #s37&lt;:AbstractSupportLabel}" href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Function,Int64,Type{#s37} where #s37&lt;:AbstractSupportLabel}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FunctionalDiscreteMeasureData(prefs::AbstractArray{GeneralVariableRef},
    coeff_func::Function,
    min_num_supports::Int,
    label::Type{&lt;:AbstractSupportLabel};
    [weight_function::Function = [`default_weight`](@ref),
    lower_bounds::AbstractArray{&lt;:Real} = [NaN...],
    upper_bounds::AbstractArray{&lt;:Real} = [NaN...],
    is_expect::Bool = false]
    )::FunctionalDiscreteMeasureData</code></pre><p>Returns a multi-dimensional <code>FunctionalDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for an array of infinite parameters. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Errors if <code>prefs</code> are not infinite parameters or if the mixed parameter types are provided. Built-in choices for <code>label</code> include:</p><ul><li><code>All</code>: Use all of the supports stored in <code>prefs</code></li><li><code>MCSample</code>: Use Monte Carlo samples associated with <code>prefs</code></li><li><code>WeightedSample</code>: Use weighted Monte Carlo samples associated with <code>prefs</code></li><li><code>UniformGrid</code>: Use uniform grid points associated with <code>prefs</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = FunctionalDiscreteMeasureData(prefs, my_func, 20, MCSample);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL362-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}" href="#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(data::AbstractMeasureData)::Union{GeneralVariableRef,
                                                 AbstractArray{GeneralVariableRef}}</code></pre><p>Return the infinite parameter reference(s) in <code>data</code>. This is intended as an internal function to be used with measure addition. User-defined measure data types will need to extend this function otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL416-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_label-Tuple{AbstractMeasureData}" href="#InfiniteOpt.support_label-Tuple{AbstractMeasureData}"><code>InfiniteOpt.support_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">support_label(data::AbstractMeasureData)::Type{&lt;:AbstractSupportLabel}</code></pre><p>Return the label stored in <code>data</code> associated with its supports. This is intended as en internal method for measure creation and ensures any new supports are added to parameters with such a label. User-defined measure data types should extend this functionif supports are used, otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL438-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generative_support_info-Tuple{AbstractMeasureData}" href="#InfiniteOpt.generative_support_info-Tuple{AbstractMeasureData}"><code>InfiniteOpt.generative_support_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generative_support_info(data::AbstractMeasureData)::AbstractGenerativeInfo</code></pre><p>Return the generative support creation info that corresponds to <code>data</code>. This is  intended as an internal method and only needs to be extended for user-defined  measure data types that use generative supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL506-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{AbstractMeasureData}" href="#JuMP.lower_bound-Tuple{AbstractMeasureData}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}</code></pre><p>Return the lower bound associated with <code>data</code> that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise <code>NaN</code> is returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL458-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{AbstractMeasureData}" href="#JuMP.upper_bound-Tuple{AbstractMeasureData}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}</code></pre><p>Return the lower bound associated with <code>data</code> that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise <code>NaN</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL476-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(data::AbstractMeasureData)::Array{Float64}</code></pre><p>Return the supports associated with <code>data</code> and its infinite parameters. This is intended as en internal method for measure creation and ensures any new supports are added to parameters. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL522-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(data::AbstractMeasureData)::Int</code></pre><p>Return the number supports associated with <code>data</code> and its infinite parameters. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise 0 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL612-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.min_num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">min_num_supports(data::AbstractMeasureData)::Int</code></pre><p>Return the minimum number of supports associated with <code>data</code>. By fallback, this will just return <code>num_supports(data)</code>. This is primarily intended for internal queries of <code>FunctionalDiscreteMeasureData</code>, but can be extended for other measure data types if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL630-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}" href="#InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficient_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coefficient_function(data::AbstractMeasureData)::Function</code></pre><p>Return the coefficient function stored in <code>data</code> associated with its expansion abstraction is there is such a function. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown for unsupported types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL647-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.coefficients-Tuple{AbstractMeasureData}" href="#InfiniteOpt.coefficients-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coefficients(data::AbstractMeasureData)::Vector{&lt;:Real}</code></pre><p>Return the coefficients associated with <code>data</code> associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL666-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.weight_function-Tuple{AbstractMeasureData}" href="#InfiniteOpt.weight_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.weight_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">weight_function(data::AbstractMeasureData)::Function</code></pre><p>Return the weight function stored in <code>data</code> associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL688-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_measure" href="#InfiniteOpt.build_measure"><code>InfiniteOpt.build_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_measure(expr::JuMP.AbstractJuMPScalar,
              data::AbstractMeasureData)::Measure</code></pre><p>Build and return a <a href="#InfiniteOpt.Measure"><code>Measure</code></a> given the expression to be measured <code>expr</code> using measure data <code>data</code>. This principally serves as an internal method for measure definition. Errors if the supports associated with <code>data</code> violate an finite variable parameter bounds of finite variables that are included in the measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL775-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_data_in_finite_var_bounds-Tuple{AbstractMeasureData,ParameterBounds}" href="#InfiniteOpt.measure_data_in_finite_var_bounds-Tuple{AbstractMeasureData,ParameterBounds}"><code>InfiniteOpt.measure_data_in_finite_var_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure_data_in_finite_var_bounds(data::AbstractMeasureData,
                            bounds::ParameterBounds)::Bool</code></pre><p>Return a <code>Bool</code> whether the domain of <code>data</code> is valid in accordance with <code>bounds</code>. This is intended as an internal method and is used to check finite variables used in measures. User-defined measure data types will need to extend this function to enable this error checking, otherwise it is skipped and a warning is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL709-L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure" href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_measure(model::InfiniteModel, meas::Measure,
            name::String = &quot;measure&quot;)::GeneralVariableRef</code></pre><p>Add a measure to <code>model</code> and return the corresponding measure reference. This operates in a manner similar to <code>JuMP.add_variable</code>. Note this intended as an internal method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1014-L1021">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}" href="#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}"><code>InfiniteOpt.add_supports_to_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_supports_to_parameters(data::AbstractMeasureData)::Nothing</code></pre><p>Add supports as appropriate with <code>data</code> to the underlying infinite parameters. This is an internal method with by <a href="#InfiniteOpt.add_measure"><code>add_measure</code></a> and should be defined for user-defined measure data types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL876-L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_function" href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return the function associated with <code>mref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; measure_function(meas)
y(x, t) + 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1054-L1064">source</a></section><section><div><pre><code class="language-julia">InfiniteOpt.measure_function(mref::GeneralVariableRef)</code></pre><p>Define <code>InfiniteOpt.measure_function</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/general_variables.jl#LL807-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_data" href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_data(mref::MeasureRef)::AbstractMeasureData</code></pre><p>Return the measure data associated with <code>mref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = measure_data(meas);

julia&gt; typeof(data)
FunctionalDiscreteMeasureData{Vector{GeneralVariableRef},Vector{Float64}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1069-L1081">source</a></section><section><div><pre><code class="language-julia">InfiniteOpt.measure_data(mref::GeneralVariableRef)</code></pre><p>Define <code>InfiniteOpt.measure_data</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/general_variables.jl#LL807-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_analytic" href="#InfiniteOpt.is_analytic"><code>InfiniteOpt.is_analytic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_analytic(mref::MeasureRef)::Bool</code></pre><p>Return if <code>mref</code> is evaluated analytically.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_analytic(meas)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1086-L1096">source</a></section><section><div><pre><code class="language-julia">InfiniteOpt.is_analytic(mref::GeneralVariableRef)</code></pre><p>Define <code>InfiniteOpt.is_analytic</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/general_variables.jl#LL807-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{MeasureRef}" href="#InfiniteOpt.parameter_refs-Tuple{MeasureRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(mref::MeasureRef)::Tuple</code></pre><p>Return the tuple of infinite parameters that the measured expression associated <code>mref</code> depends on once the measure has been evaluated. Note that this will correspond to the parameter dependencies of the measure function excluding those included in the measure data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(meas)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1122-L1135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure" href="#InfiniteOpt.measure"><code>InfiniteOpt.measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure(expr::JuMP.AbstractJuMPScalar,
        data::AbstractMeasureData;
        [name::String = &quot;measure&quot;])::GeneralVariableRef</code></pre><p>Return a measure reference that evaluates <code>expr</code> using according to <code>data</code>. The measure data <code>data</code> determines how the measure is to be evaluated. Typically, the <code>DiscreteMeasureData</code> and the <code>FunctionalDiscreteMeasureData</code> constructors can be used to for <code>data</code>. The variable expression <code>expr</code> can contain <code>InfiniteOpt</code> variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Typically, this is called inside of <a href="../../JuMP/#JuMP.@expression"><code>JuMP.@expression</code></a>, <a href="../../JuMP/#JuMP.@objective"><code>JuMP.@objective</code></a>, and <a href="../../JuMP/#JuMP.@constraint"><code>JuMP.@constraint</code></a> in a manner similar to <code>sum</code>. Note measures are not explicitly evaluated until <a href="../optimize/#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> is called or unless they are expanded via <a href="#InfiniteOpt.expand"><code>expand</code></a> or <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2]);

julia&gt; xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]]);

julia&gt; constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)
measure{t}[g(t) - s + 2] + s²

julia&gt; @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))
measure{xs}[g(t) - 1 + measure{xs}[T(t, x)]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1154-L1182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@measure" href="#InfiniteOpt.@measure"><code>InfiniteOpt.@measure</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@measure(expr::JuMP.AbstractJuMPScalar,
         data::AbstractMeasureData;
         [name::String = &quot;measure&quot;])::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.measure"><code>measure</code></a>, please see its doc string for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1194-L1201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(mref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1260-L1270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1245-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_objective(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_objective(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1275-L1285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{MeasureRef}" href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1305-L1315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{MeasureRef}" href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(mref::MeasureRef)::String</code></pre><p>Extend <code>JuMP.name</code> to return the name associated with a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1221-L1226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{MeasureRef,String}" href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(mref::MeasureRef, name::String)::Nothing</code></pre><p>Extend <code>JuMP.set_name</code> to specify the name of a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1232-L1236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_measures" href="#InfiniteOpt.num_measures"><code>InfiniteOpt.num_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_measures(model::InfiniteModel)::Int</code></pre><p>Return the number of measures defined in <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_measures(model)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1324-L1334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_measures" href="#InfiniteOpt.all_measures"><code>InfiniteOpt.all_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_measures(model::InfiniteModel)::Vector{GeneralVariableRef}</code></pre><p>Return the list of all measures added to <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all_measures(model)
2-element Array{GeneralVariableRef,1}:
 ∫{t ∈ [0, 6]}[w(t, x)]
 𝔼{x}[w(t, x)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1339-L1351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,MeasureRef}" href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, mref::MeasureRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min ∫{t ∈ [0, 6]}[g(t)] + z
Subject to
 z ≥ 0.0
 ∫{t ∈ [0, 6]}[g(t)] = 0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0

julia&gt; delete(model, meas)

julia&gt; print(model)
Min z
Subject to
 z ≥ 0.0
 0 = 0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measures.jl#LL1363-L1389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand" href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return a JuMP scalar function containing the explicit expansion of the measure <code>mref</code>. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and semi-infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with <a href="#InfiniteOpt.measure"><code>measure</code></a> to expand measures on the fly.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. Optionally, <a href="#InfiniteOpt.analytic_expansion"><code>analytic_expansion</code></a> can also be extended which is triggered by <a href="#InfiniteOpt.is_analytic"><code>is_analytic</code></a> for such types if analytic expansion is possible in certain cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])

julia&gt; expr = expand(measure(g + z + T - h - 2, tdata))
0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL704-L729">source</a></section><section><div><pre><code class="language-none">InfiniteOpt.expand(mref::GeneralVariableRef)</code></pre><p>Define <code>InfiniteOpt.expand</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/general_variables.jl#LL807-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_all_measures!" href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_all_measures!(model::InfiniteModel)::Nothing</code></pre><p>Expand all of the measures used in the objective and/or constraints of <code>model</code>. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and semi-infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before <code>model</code> is translated into the new model. This method can also be extended to handle custom measure data types by extending <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. Note that this method leverages <code>expand_measure</code> via <a href="#InfiniteOpt.expand_measures"><code>expand_measures</code></a>. Optionally, <a href="#InfiniteOpt.analytic_expansion"><code>analytic_expansion</code></a> can also be extended which is triggered by <a href="#InfiniteOpt.is_analytic"><code>is_analytic</code></a> for such types if analytic expansion is possible in certain cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min integral{t ∈ [0, 6]}[g(t)*t] + z
Subject to
 T(t, x) ≥ 0.0, ∀ t ∈ [0, 6], xi ∈ [-1, 1]
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 integral{t ∈ [0, 6]}[T(t, x)] ≥ 0.0, ∀ x ∈ [-1, 1]

julia&gt; expand_all_measures!(model)

julia&gt; print(model)
Min 3 g(6) + z
Subject to
 T(t, x) ≥ 0.0, ∀ t ∈ [0, 6], xi ∈ [-1, 1]
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 0.5 T(0, x) + 0.5 T(6, xi) ≥ 0.0, ∀ x ∈ [-1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL805-L842">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_measure" href="#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_measure(expr, data::AbstractMeasureData,
               write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Return the finite reformulation of a measure containing a variable/parameter expression <code>expr</code> with measure data <code>data</code>. Here <code>write_model</code> is the target model where this expanded expression will be used. Thus, any variables that need to be created will be added to <code>write_model</code>. The methods <a href="#InfiniteOpt.make_point_variable_ref"><code>make_point_variable_ref</code></a> and <a href="#InfiniteOpt.make_semi_infinite_variable_ref"><code>make_semi_infinite_variable_ref</code></a> should be used as appropriate to create these variables. Developers might also choose to use <a href="#InfiniteOpt.delete_internal_semi_infinite_variable"><code>delete_internal_semi_infinite_variable</code></a> in order to remove semi-infinite variables once they are no longer needed. Note this is intended as an internal function, but will need to be extended for unsupported <code>expr</code> types and for user-defined measure data types. Principally, this is leveraged to enable the user methods <a href="#InfiniteOpt.expand"><code>expand</code></a> and <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL185-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.analytic_expansion" href="#InfiniteOpt.analytic_expansion"><code>InfiniteOpt.analytic_expansion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analytic_expansion(expr, data::AbstractMeasureData,
                   write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Analytically, evaluate measure in the simple case where the measure expression <code>expr</code> doesn&#39;t depend on <code>data</code> and thus <code>expr</code> can be treated as a constant in conjunction with an analytic result of the <code>data</code>. This is intended as an internal method that is used by <a href="#InfiniteOpt.expand"><code>expand</code></a> and <a href="#InfiniteOpt.expand_measures"><code>expand_measures</code></a>. For unrecognized <code>data</code> types, <code>expand_measure</code> is called instead. User defined measure data type may choose to extend this method if desired. This is triggered when <code>is_analytic(mref) = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL632-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_measures" href="#InfiniteOpt.expand_measures"><code>InfiniteOpt.expand_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_measures(expr, write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Expand all <code>MeasureRef</code>s in <code>expr</code> in-place via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a> and return the expanded expression. This is an internal method used by <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a> and <code>TranscriptionOpt</code> but can be useful for user-defined optimizer model extensions that add implement <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> in combination with <code>expand_measure</code>. <code>write_model</code> is the model that the measure variables are added to as described in <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL741-L751">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_point_variable_ref" href="#InfiniteOpt.make_point_variable_ref"><code>InfiniteOpt.make_point_variable_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_point_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},
                        ivref::GeneralVariableRef,
                        support::Vector{Float64}
                        )::GeneralVariableRef</code></pre><p>Make a point variable for infinite variable/derivative <code>ivref</code> at <code>support</code>, add it to the <code>write_model</code>, and return the <code>GeneralVariableRef</code>. This is an internal method for point variables produced by expanding measures via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the <code>InfiniteModel</code>. In such cases, <code>write_model</code> should be the optimizer model and <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> should be extended appropriately for point variables. Errors if <code>write_model</code> is an optimizer model and <code>add_measure_variable</code> is not properly extended.</p><p>Note this is also accomodates infinite parameter functions, in which case the  infinite parameter function is called with the support as input. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_semi_infinite_variable_ref" href="#InfiniteOpt.make_semi_infinite_variable_ref"><code>InfiniteOpt.make_semi_infinite_variable_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_semi_infinite_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},
                          ivref::GeneralVariableRef,
                          indices::Vector{Int},
                          values::Vector{Float64}
                          )::GeneralVariableRef</code></pre><p>Make a semi-infinite variable for infinite variable/derivative/parameter function <code>ivref</code> at <code>support</code>, add it to the <code>write_model</code>, and return the <code>GeneralVariableRef</code>. This is an internal method for semi-infinite variables produced by expanding measures via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the <code>InfiniteModel</code>. In such cases, <code>write_model</code> should be the optimizer model and <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> should be extended appropriately for semi-infinite variables. Errors if <code>write_model</code> is an optimizer model and <code>add_measure_variable</code> is not properly extended. Note this is only intended for optimizer models that are currently stored in <code>InfiniteModel.optimizer_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL98-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}" href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.add_measure_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_measure_variable(model::JuMP.Model, var,
                     key::Val{:ext_key_name})::GeneralVariableRef</code></pre><p>Add a measure variable <code>var</code> to the optimizer model <code>model</code> (with <code>key</code>) and return the correct <code>InfiniteOpt</code> variable reference. This is an internal method used by <a href="#InfiniteOpt.make_point_variable_ref"><code>make_point_variable_ref</code></a> and <a href="#InfiniteOpt.make_semi_infinite_variable_ref"><code>make_semi_infinite_variable_ref</code></a> to make point variables and semi-infinite variables when the <code>write_model</code> is an optimizer model. This is useful for extensions that wish to expand measures, but without changing the original <code>InfiniteModel</code>. Thus, this should be extended for adding <code>PointVariable</code>s and <code>SemiInfiniteVariable</code>s for such extensions. Otherwise, an error is thrown for unextended variable and/or optimizer model types. Note if this is extended, than <a href="#InfiniteOpt.internal_semi_infinite_variable"><code>internal_semi_infinite_variable</code></a> should also be extended in order to direct semi-infinite variables references to the underlying <a href="#InfiniteOpt.SemiInfiniteVariable"><code>SemiInfiniteVariable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL53-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_internal_semi_infinite_variable" href="#InfiniteOpt.delete_internal_semi_infinite_variable"><code>InfiniteOpt.delete_internal_semi_infinite_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete_internal_semi_infinite_variable(write_model::Union{InfiniteModel, JuMP.Model},
                                 rvref::SemiInfiniteVariableRef)::Nothing</code></pre><p>Delete the variable associated with <code>rvref</code> from <code>write_model</code> if it is purely an internal variable only used for measure expansion and is no longer needed. For <code>write_model</code>s that are an optimizer model, <a href="#InfiniteOpt.delete_semi_infinite_variable-Tuple{Model,Any,Any}"><code>delete_semi_infinite_variable</code></a> will need to be extended for this this to work. Otherwise, a warning will be thrown. Note that this is intended as an internal method to assist with extensions to <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL138-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_semi_infinite_variable-Tuple{Model,Any,Any}" href="#InfiniteOpt.delete_semi_infinite_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.delete_semi_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_semi_infinite_variable(model::JuMP.Model, vref, key::Val{:ext_key_name})::Nothing</code></pre><p>Delete the semi-infinite variable associated with <code>vref</code> from the optimizer model <code>model</code> with associated extension key <code>:ext_key_name</code>. A warning is thrown if this is not properly extended. This is intended as a helper function for <a href="#InfiniteOpt.delete_internal_semi_infinite_variable"><code>delete_internal_semi_infinite_variable</code></a> which is used by <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/measure_expansions.jl#LL158-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.internal_semi_infinite_variable" href="#InfiniteOpt.internal_semi_infinite_variable"><code>InfiniteOpt.internal_semi_infinite_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">internal_semi_infinite_variable(vref::SemiInfiniteVariableRef,
                                key::Val{:my_ext_key})::SemiInfiniteVariable</code></pre><p>Return the semi-infinite variable object of <code>vref</code> assuming it is an internal variable made during measure expansion within an optimizer model. This will apply to optimizer model extensions that utilize <code>add_measure_variable</code> in combination with <code>expand_measure</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}" href="#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, ivref::GeneralVariableRef,
                    eval_supports::Dict{Int, Float64}; [check::Bool = true]
                    )::SemiInfiniteVariable{GeneralVariableRef}</code></pre><p>Extend the <code>JuMP.build_variable</code> function to build a semi-infinite variable based on the infinite variable/derivative/parameter function <code>ivref</code> with reduction support <code>eval_supports</code>. Will check that input is appropriate if <code>check = true</code>. Errors if <code>ivref</code> is not an infinite variable, <code>eval_supports</code> violate infinite parameter domains, or if the support dimensions don&#39;t match the infinite parameter dimensions of <code>ivref</code>. This is intended an internal method for use in evaluating measures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL75-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_variable-Tuple{InfiniteModel,SemiInfiniteVariable,String}" href="#JuMP.add_variable-Tuple{InfiniteModel,SemiInfiniteVariable,String}"><code>JuMP.add_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_variable(model::InfiniteModel, var::InfOptVariable,
                  [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Extend the <a href="../JuMP/#JuMP.add_variable"><code>JuMP.add_variable</code></a> function to accomodate <code>InfiniteOpt</code> variable types. Adds a variable to an infinite model <code>model</code> and returns a <a href="expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>. Primarily intended to be an internal function of the constructor macros <a href="#InfiniteOpt.@infinite_variable"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@finite_variable"><code>@finite_variable</code></a>. However, it can be used in combination with <a href="measure/#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a> to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in <code>var</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 10]);

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);

julia&gt; inf_var = build_variable(error, info, Infinite, parameter_refs = t);

julia&gt; ivref = add_variable(m, inf_var, &quot;var_name&quot;)
var_name(t)

julia&gt; pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,
                               parameter_values = 0.5);

julia&gt; pvref = add_variable(m, pt_var, &quot;var_alias&quot;)
var_alias

julia&gt; f_var = build_variable(error, info, Finite);

julia&gt; fvref = add_variable(m, f_var, &quot;var_name&quot;)
var_name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/variable_basics.jl#LL114-L150">source</a></section><section><div><pre><code class="language-none">JuMP.add_variable(model::InfiniteModel, var::SemiInfiniteVariable,
                  [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Extend the <a href="../../JuMP/#JuMP.add_variable"><code>JuMP.add_variable</code></a> function to accomodate <code>InfiniteOpt</code> semi-infinite variable types. Adds <code>var</code> to the infinite model <code>model</code> and returns a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>. Primarily intended to be an internal function used in evaluating measures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL127-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_variable_ref(vref::SemiInfiniteVariableRef)::GeneralVariableRef</code></pre><p>Return the infinite variable/derivative/parameter function reference associated  with the semi-infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_variable_ref(vref)
g(t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL150-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.eval_supports-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.eval_supports-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_supports(vref::SemiInfiniteVariableRef)::Dict{Int, Float64}</code></pre><p>Return the evaluation supports associated with the semi-infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; eval_supports(vref)
Dict{Int64,Float64} with 1 entry:
  1 =&gt; 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL166-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(vref::SemiInfiniteVariableRef)::Tuple</code></pre><p>Return the infinite parameter references associated with the semi-infinite variable <code>vref</code>. This is formatted as a <code>Tuple</code> of containing the parameter references as they were inputted to define the untranscripted infinite variable except, the evaluated parameters are excluded.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(vref)
(t, [x[1], x[2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL199-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.parameter_list-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(vref::SemiInfiniteVariableRef)::Vector{GeneralVariableRef}</code></pre><p>Return a vector of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(vref::SemiInfiniteVariableRef)::VectorTuple{GeneralVariableRef}</code></pre><p>Return the raw <a href="../variable/#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{SemiInfiniteVariableRef,String}" href="#JuMP.set_name-Tuple{SemiInfiniteVariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing</code></pre><p>Extend <a href="../JuMP/#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> to set names of decision variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(vref, &quot;var_name&quot;)

julia&gt; name(vref)
&quot;var_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/variable_basics.jl#LL253-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{SemiInfiniteVariableRef}" href="#JuMP.has_lower_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL280-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{SemiInfiniteVariableRef}" href="#JuMP.lower_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(vref::SemiInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a> to return the lower bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL296-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.LowerBoundRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>JuMP.LowerBoundRef</code></a> to extract a constraint reference for the lower bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = LowerBoundRef(vref)
var &gt;= 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL326-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{SemiInfiniteVariableRef}" href="#JuMP.has_upper_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL342-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{SemiInfiniteVariableRef}" href="#JuMP.upper_bound-Tuple{SemiInfiniteVariableRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(vref::SemiInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> to return the upper bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL358-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.UpperBoundRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>JuMP.UpperBoundRef</code></a> to extract a constraint reference for the upper bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = UpperBoundRef(vref)
var &lt;= 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL388-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{SemiInfiniteVariableRef}" href="#JuMP.is_fixed-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_fixed(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_fixed-Tuple{VariableRef}"><code>JuMP.is_fixed</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_fixed(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL404-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{SemiInfiniteVariableRef}" href="#JuMP.fix_value-Tuple{SemiInfiniteVariableRef}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix_value(vref::SemiInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.fix_value-Tuple{VariableRef}"><code>JuMP.fix_value</code></a> to return the fix value of the original infinite variable of <code>vref</code>. Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fix_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL420-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.FixRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.FixRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.FixRef-Tuple{VariableRef}"><code>JuMP.FixRef</code></a> to return the constraint reference of the fix constraint associated with the original infinite variable of <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cref = FixRef(vref)
var == 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL450-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.start_value_function-Tuple{SemiInfiniteVariableRef}" href="#InfiniteOpt.start_value_function-Tuple{SemiInfiniteVariableRef}"><code>InfiniteOpt.start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_value_function(vref::SemiInfiniteVariableRef)::Union{Nothing, Function}</code></pre><p>Return the function that is used to generate the start values of <code>vref</code> for particular support values. Returns <code>nothing</code> if no start behavior has been specified.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; start_value_func(vref)
my_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL472-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{SemiInfiniteVariableRef}" href="#JuMP.is_binary-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_binary(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_binary-Tuple{VariableRef}"><code>JuMP.is_binary</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is binary.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_binary(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL489-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.BinaryRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.BinaryRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.BinaryRef-Tuple{VariableRef}"><code>JuMP.BinaryRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL515-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{SemiInfiniteVariableRef}" href="#JuMP.is_integer-Tuple{SemiInfiniteVariableRef}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_integer(vref::SemiInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_integer-Tuple{VariableRef}"><code>JuMP.is_integer</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is integer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL532-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{SemiInfiniteVariableRef}" href="#JuMP.IntegerRef-Tuple{SemiInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.IntegerRef(vref::SemiInfiniteVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.IntegerRef-Tuple{VariableRef}"><code>JuMP.IntegerRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/semi_infinite_variables.jl#LL558-L570">source</a></section></article><h2 id="MeasureToolbox-Datatypes"><a class="docs-heading-anchor" href="#MeasureToolbox-Datatypes">MeasureToolbox Datatypes</a><a id="MeasureToolbox-Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#MeasureToolbox-Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.MeasureToolbox.AbstractIntegralMethod"><code>InfiniteOpt.MeasureToolbox.AbstractIntegralMethod</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>InfiniteOpt.MeasureToolbox.Automatic</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>InfiniteOpt.MeasureToolbox.FEGaussLobatto</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>InfiniteOpt.MeasureToolbox.GaussChebyshev</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>InfiniteOpt.MeasureToolbox.GaussHermite</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussJacobi"><code>InfiniteOpt.MeasureToolbox.GaussJacobi</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>InfiniteOpt.MeasureToolbox.GaussLaguerre</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>InfiniteOpt.MeasureToolbox.GaussLegendre</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>InfiniteOpt.MeasureToolbox.GaussLobatto</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussRadau"><code>InfiniteOpt.MeasureToolbox.GaussRadau</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.InternalGaussLobatto"><code>InfiniteOpt.MeasureToolbox.InternalGaussLobatto</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiIndepMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>InfiniteOpt.MeasureToolbox.Quadrature</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.UniIndepMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>InfiniteOpt.MeasureToolbox.UniMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>InfiniteOpt.MeasureToolbox.UniTrapezoid</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractIntegralMethod" href="#InfiniteOpt.MeasureToolbox.AbstractIntegralMethod"><code>InfiniteOpt.MeasureToolbox.AbstractIntegralMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods use in combination with <code>integral</code> and <code>generate_integral_data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.Automatic" href="#InfiniteOpt.MeasureToolbox.Automatic"><code>InfiniteOpt.MeasureToolbox.Automatic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Automatic &lt;: AbstractIntegralMethod</code></pre><p>An integral evaluation type for automically selecting an appropriate integral evaluation method. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod" href="#InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractUnivariateMethod &lt;: AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods for 1-dimensional integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniTrapezoid" href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>InfiniteOpt.MeasureToolbox.UniTrapezoid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniTrapezoid &lt;: AbstractUnivariateMethod</code></pre><p>An integral evalution method that uses the trapezoid rule to in combination with all parameter supports available when the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this method will ignore the <code>num_supports</code> keyword argument. Note this is valid only for finite integral domains. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniMCSampling" href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>InfiniteOpt.MeasureToolbox.UniMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniMCSampling &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy <code>num_supports</code> and it will include all supports with the <code>MCSample</code> label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniIndepMCSampling" href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.UniIndepMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniIndepMCSampling &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to <a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling</code></a>. However, this variant will generate its own set of supports and ignore all other supports with the <code>MCSample</code> label. Note this is valid only for finite integral domains. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.Quadrature" href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>InfiniteOpt.MeasureToolbox.Quadrature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quadrature &lt;: AbstractUnivariateMethod</code></pre><p>A general integral evaluation method that will automatically select the appropriate quadrature method to approximate the integral. Please note that this will generate a unique set of parameter supports and will ignore existing supports when the integral is evaluated and thus should be used with caution. However, this method is able to handle infinite and semi-infinite integral domains. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL68-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussHermite" href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>InfiniteOpt.MeasureToolbox.GaussHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussHermite &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaulation method that uses Gauss-Hermite quadrature to evaluate integrals. This is valid for infinite integral domains.  It will take this form:</p><p><span>$\int_{-∞}^{∞} f(x) e^{-x^2} \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p><p>Using the weight function: <span>$w(x)$</span> = <span>$e^{-x^2}$</span></p><p>Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL213-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussLegendre" href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>InfiniteOpt.MeasureToolbox.GaussLegendre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussLegendre &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Legendre quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussRadau" href="#InfiniteOpt.MeasureToolbox.GaussRadau"><code>InfiniteOpt.MeasureToolbox.GaussRadau</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussRadau &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Radau quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussLobatto" href="#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>InfiniteOpt.MeasureToolbox.GaussLobatto</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussLobatto &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Lobatto quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussJacobi" href="#InfiniteOpt.MeasureToolbox.GaussJacobi"><code>InfiniteOpt.MeasureToolbox.GaussJacobi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussJacobi &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Jacobi quadrature to evaluate integrals. It will take this form:</p><p><span>$\int_{-1}^{1} f(x) (1-x)^\alpha (1+x)^\beta dx \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p><p>Where, </p><p><span>$(1-x)^\alpha (1+x)^\beta$</span> </p><p>is the weight function. This is valid for finite integral domains. This requires the user to input the alpha and beta shape parameters for their function. This will then generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. If α or β is &lt; -1, an error will be returned.  </p><p><strong>Fields</strong></p><ul><li><code>α::Float64</code>: Shape parameter that must be &gt; -1</li><li><code>β::Float64</code>: Shape parameter that must be &gt; -1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL126-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.FEGaussLobatto" href="#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>InfiniteOpt.MeasureToolbox.FEGaussLobatto</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FEGaussLobatto &lt;: AbstractUnivariateMethod</code></pre><p>Integral evaluation method that allows for the user to specify supports to be included in quadrature evaluation. This method uses Gauss Lobatto quadrature to decompose the overall Integral into smaller integrals that span the user defined supports as follows:</p><p><span>$\int_{x_1}^{x_3} f(x) dx = \int_{x_1}^{x_2} f(x) dx + \int_{x_2}^{x_3} f(x) dx$</span></p><p>where the integrals are evaluated using Gauss Lobatto quadrature:</p><p><span>$\int f(x) dx \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL80-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussChebyshev" href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>InfiniteOpt.MeasureToolbox.GaussChebyshev</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussChebyshev &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Chebyshev quadrature to evaluate integrals. This is valid for finite integral domains. This requires the user to input the order of Guass-Chebyshev Quadrature they want to use.  If the order is not between 1 and 4 an error will be returned.  The integral evaluated is as follows:</p><p><span>$\int_{-1}^{1} f(x) w(x) \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p><p>The weight functions are as follows: </p><ul><li>1st order: <span>$w(x)  =  \frac{1}{\sqrt{1-x^2}}$</span></li><li>2nd order: <span>$w(x) = {\sqrt{1-x^2}}$</span></li><li>3rd order: <span>$w(x) = \sqrt{(1+x)/(1-x)}$</span></li><li>4th order: <span>$w(x) = \sqrt{(1-x)/(1+x)}$</span></li></ul><p>This will then generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p><p><strong>Fields</strong></p><ul><li><code>order::Int</code>: Specifies the order of Gauss-Chebyshev Quadrature. Must be between 1 and 4.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL160-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussLaguerre" href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>InfiniteOpt.MeasureToolbox.GaussLaguerre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussLaguerre &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaulation method that uses Gauss-Laguerre quadrature to evaluate integrals. This is valid for semi-infinite integral domains. </p><p>This method evaluates the following integral:</p><p><span>$\int_{0}^{+∞} f(x) e^{-x} \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p><p>Using the weight function:</p><p><span>$w(x) = e^{-x}$</span></p><p>Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL194-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod" href="#InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractMultivariateMethod &lt;: AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods for multi-dimensional integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.MultiMCSampling" href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiMCSampling &lt;: AbstractMultivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy <code>num_supports</code> and it will include all supports with the <code>MCSample</code> label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains. If an array of independent infinite parameters is specified, they must use the same amount of supports. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL237-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.MultiIndepMCSampling" href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiIndepMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiIndepMCSampling &lt;: AbstractMultivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to <a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling</code></a>. However, this variant will generate its own set of supports and ignore all other supports with the <code>MCSample</code> label. Note this is valid only for finite integral domains. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL250-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.InternalGaussLobatto" href="#InfiniteOpt.MeasureToolbox.InternalGaussLobatto"><code>InfiniteOpt.MeasureToolbox.InternalGaussLobatto</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InternalGaussLobatto &lt;: InfiniteOpt.InternalLabel</code></pre><p>A support label Gauss Lobatto points that are used as generative supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL264-L268">source</a></section></article><h2 id="MeasureToolbox-Methods"><a class="docs-heading-anchor" href="#MeasureToolbox-Methods">MeasureToolbox Methods</a><a id="MeasureToolbox-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#MeasureToolbox-Methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.MeasureToolbox.@expect"><code>InfiniteOpt.MeasureToolbox.@expect</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.@integral"><code>InfiniteOpt.MeasureToolbox.@integral</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>InfiniteOpt.MeasureToolbox.@support_sum</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.@∫"><code>InfiniteOpt.MeasureToolbox.@∫</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.@𝔼"><code>InfiniteOpt.MeasureToolbox.@𝔼</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.expect"><code>InfiniteOpt.MeasureToolbox.expect</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>InfiniteOpt.MeasureToolbox.generate_integral_data</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s37,N} where N where #s37&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>InfiniteOpt.MeasureToolbox.integral</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>InfiniteOpt.MeasureToolbox.integral</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.multi_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_multi_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_uni_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.support_sum"><code>InfiniteOpt.MeasureToolbox.support_sum</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.uni_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>InfiniteOpt.MeasureToolbox.∫</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s37,N} where N where #s37&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>InfiniteOpt.MeasureToolbox.∫</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.𝔼"><code>InfiniteOpt.MeasureToolbox.𝔼</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@integral" href="#InfiniteOpt.MeasureToolbox.@integral"><code>InfiniteOpt.MeasureToolbox.@integral</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@integral(expr::JuMP.AbstractJuMPScalar,
          prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}},
          [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds,
          upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds;
          kwargs...])::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> and <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s37,N} where N where #s37&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>integral</code></a>. Please see the above doc strings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL1036-L1046">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@∫" href="#InfiniteOpt.MeasureToolbox.@∫"><code>InfiniteOpt.MeasureToolbox.@∫</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@∫(expr::JuMP.AbstractJuMPScalar,
   prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}},
   [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds,
   upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds;
   kwargs...])::GeneralVariableRef</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a>. The unicode symbol <code>∫</code> is produced  via <code>\int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL1060-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}" href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>InfiniteOpt.MeasureToolbox.integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integral(expr::JuMP.AbstractJuMPScalar,
         pref::GeneralVariableRef,
         [lower_bound::Real = lower_bound(pref),
         upper_bound::Real = upper_bound(pref);
         kwargs...])::GeneralVariableRef</code></pre><p>Returns a measure reference that evaluates the integral of <code>expr</code> with respect to infinite parameter <code>pref</code> from <code>lower_bound</code> to <code>upper_bound</code>. This thus considers integrals of the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter and <span>$w$</span> is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> via <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> in accordance with the keyword arugment <code>eval_method</code> that is then used with <a href="#InfiniteOpt.measure"><code>measure</code></a>. Note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a> when <code>expr</code> is not just a single variable reference. Errors for bad bound input.</p><p>The keyword arguments are as follows:</p><ul><li><code>eval_method::AbstractUnivariateMethod</code>: Used to determine the   numerical evaluation scheme. Possible choices include:<ul><li><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>UniTrapezoid()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>UniIndepMCSampling()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>Quadrature()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>GaussHermite()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>GaussLegendre()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>FEGaussLobatto()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>GaussLageurre()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>GaussLobatto()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(order)</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussRadau"><code>GaussRadau()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussJacobi"><code>GaussJacobi(α, β)</code></a></li></ul></li><li><code>num_supports</code>: The minimum number of supports to be generated (if used by   <code>eval_method</code>)</li><li><code>weight_func</code>: <span>$w(p)$</span> above with parameter value inputs and scalar output</li></ul><p>See <a href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>set_uni_integral_defaults</code></a> to update the default keyword argument values for all one-dimensional integral calls.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1])
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; int = integral(f, x)
∫{x ∈ [0, 1]}[f(x)]

julia&gt; expand(int)
0.2 f(0.8236475079774124) + 0.2 f(0.9103565379264364) + 0.2 f(0.16456579813368521) + 0.2 f(0.17732884646626457) + 0.2 f(0.278880109331201)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL751-L805">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s37,N} where N where #s37&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}" href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s37,N} where N where #s37&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>InfiniteOpt.MeasureToolbox.integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integral(expr::JuMP.AbstractJuMPScalar,
         prefs::AbstractArray{GeneralVariableRef},
         [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = [lower_bound(pref)...],
         upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = [upper_bound(pref)...];
         kwargs...])::GeneralVariableRef</code></pre><p>Returns a measure reference that evaluates the integral of <code>expr</code> with respect to infinite parameters <code>prefs</code> from <code>lower_bounds</code> to <code>upper_bounds</code>. This thus considers integrals of the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter and <span>$w$</span> is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> via <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> in accordance with the keyword arugment <code>eval_method</code> that is then used with <a href="#InfiniteOpt.measure"><code>measure</code></a>. Note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a> when <code>expr</code> is not just a single variable reference. Errors when the container types and dimensions do not match or the bounds are invalid.</p><p>The keyword arguments are as follows:</p><ul><li><code>eval_method::AbstractMultivariateMethod</code>: Used to determine the   numerical evaluation scheme. Possible choices include:<ul><li><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>MultiIndepMCSampling()</code></a></li></ul></li><li><code>num_supports</code>: The minimum number of supports to be generated (if used by   <code>eval_method</code>)</li><li><code>weight_func</code>: <span>$w(p)$</span> above with parameter value inputs and scalar output</li></ul><p>See <a href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>set_multi_integral_defaults</code></a> to update the default keyword argument values for all multi-dimensional integral calls.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:2] in [0, 1], independent = true);

julia&gt; @infinite_variable(model, f(x));

julia&gt; int = integral(f, x)
∫{x ∈ [0, 1]^2}[f(x)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL930-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}" href="#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>InfiniteOpt.MeasureToolbox.∫</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∫(expr::JuMP.AbstractJuMPScalar,
  pref::GeneralVariableRef,
  [lower_bound::Real = NaN,
  upper_bound::Real = NaN;
  kwargs...])::GeneralVariableRef</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a>. The <code>∫</code> unicode symbol is produced  via <code>\int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL836-L845">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s37,N} where N where #s37&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}" href="#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s37,N} where N where #s37&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>InfiniteOpt.MeasureToolbox.∫</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∫(expr::JuMP.AbstractJuMPScalar,
  prefs::AbstractArray{GeneralVariableRef},
  [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = NaN,
  upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = NaN;
  kwargs...])::GeneralVariableRef</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a>. The unicode symbol <code>∫</code> is produced  via <code>\int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL1018-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@expect" href="#InfiniteOpt.MeasureToolbox.@expect"><code>InfiniteOpt.MeasureToolbox.@expect</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@expect(expr::JuMP.AbstractJuMPScalar,
        prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};
        [min_num_supports::Int = DefaultNumSupports])::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a>. Please see its doc string more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/expectations.jl#LL98-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@𝔼" href="#InfiniteOpt.MeasureToolbox.@𝔼"><code>InfiniteOpt.MeasureToolbox.@𝔼</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@𝔼(expr::JuMP.AbstractJuMPScalar,
   prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};
   [min_num_supports::Int = DefaultNumSupports])::GeneralVariableRef</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a>. The unicode symbol <code>𝔼</code> is produced by  <code>\bbE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/expectations.jl#LL138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.expect" href="#InfiniteOpt.MeasureToolbox.expect"><code>InfiniteOpt.MeasureToolbox.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expect(expr::JuMP.AbstractJuMPScalar,
       prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};
       [min_num_supports::Int = DefaultNumSupports])::GeneralVariableRef</code></pre><p>Creates a measure that represents the expected value of an expression based on <code>prefs</code>. If <code>prefs</code> are not random parameters then this will be equivalent to the following call:</p><pre><code class="language-julia">1/total_num_supports * support_sum(expr, prefs)</code></pre><p>Note that min<em>num</em>supports should be 0 if a single dependent parameter is given. Also, note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a> when <code>expr</code> is not just a single variable reference.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in Normal())
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = expect(f, min_num_supports = 2)
𝔼{x}[f(x)]

julia&gt; expand(meas)
0.5 f(0.6791074260357777) + 0.5 f(0.8284134829000359)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/expectations.jl#LL32-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.𝔼" href="#InfiniteOpt.MeasureToolbox.𝔼"><code>InfiniteOpt.MeasureToolbox.𝔼</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">𝔼(expr::JuMP.AbstractJuMPScalar,
  prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}};
  [min_num_supports::Int = DefaultNumSupports]
  )::GeneralVariableRef)</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a>. The unicode symbol <code>𝔼</code> is produced by  <code>\bbE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/expectations.jl#LL122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@support_sum" href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>InfiniteOpt.MeasureToolbox.@support_sum</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@support_sum(expr::JuMP.AbstractJuMPScalar,
             params::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}}
             )::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.support_sum"><code>support_sum</code></a> please see its doc string for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/support_sums.jl#LL46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.support_sum" href="#InfiniteOpt.MeasureToolbox.support_sum"><code>InfiniteOpt.MeasureToolbox.support_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support_sum(expr::JuMP.AbstractJuMPScalar,
            params::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}}
            )::GeneralVariableRef</code></pre><p>Creates a measure that represents the sum of the expression over a parameter(s) using all of its supports. Also, note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>@support_sum</code></a> when <code>expr</code> is not just a single variable reference.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1], supports = [0.3, 0.7])
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = support_sum(f, x)
support_sum{x}[f(x)]

julia&gt; expand(meas)
f(0.3) + f(0.7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/support_sums.jl#LL7-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.uni_integral_defaults" href="#InfiniteOpt.MeasureToolbox.uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.uni_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uni_integral_defaults()::Dict{Symbol, Any}</code></pre><p>Get the default keyword argument values for defining one-dimensional integrals.</p><pre><code class="language-julia-repl">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL681-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.set_uni_integral_defaults" href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_uni_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_uni_integral_defaults(; kwargs...)::Nothing</code></pre><p>Set the default keyword argument settings for one-dimensional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> with a single infinite parameter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()


julia&gt; set_uni_integral_defaults(num_supports = 5, eval_method = Quadrature(),
                                 new_kwarg = true)

julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Quadrature()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL694-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults" href="#InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clear_uni_integral_defaults()::Nothing</code></pre><p>Clears and resets the keyword argument defaults for univariate integrals to their  default state. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Quadrature()

julia&gt; clear_uni_integral_defaults()

julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL725-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.multi_integral_defaults" href="#InfiniteOpt.MeasureToolbox.multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.multi_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">multi_integral_defaults()::Dict{Symbol, Any}</code></pre><p>Get the default keyword argument values for defining multi-dimensional integrals.</p><pre><code class="language-julia-repl">julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL860-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.set_multi_integral_defaults" href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_multi_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_multi_integral_defaults(; kwargs...)::Nothing</code></pre><p>Set the default keyword argument settings for multi-dimesnional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s37,N} where N where #s37&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>integral</code></a> with an array of infinite parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()

julia&gt; set_multi_integral_defaults(num_supports = 5, new_kwarg = true)

julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL873-L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults" href="#InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clear_multi_integral_defaults()::Nothing</code></pre><p>Clears and resets the keyword argument defaults for multivariate integrals to their  default state. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Automatic()

julia&gt; clear_multi_integral_defaults()

julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL902-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.generate_integral_data" href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>InfiniteOpt.MeasureToolbox.generate_integral_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_integral_data(
    prefs::Union{InfiniteOpt.GeneralVariableRef, Vector{InfiniteOpt.GeneralVariableRef}},
    lower_bounds::Union{Real, Vector{&lt;:Real}},
    upper_bounds::Union{Real, Vector{&lt;:Real}},
    method::V; [num_supports::Int = InfiniteOpt.DefaultNumSupports,
    weight_func::Function = InfiniteOpt.default_weight,
    extra_kwargs...]
    )::InfiniteOpt.AbstractMeasureData where {V &lt;: AbstractIntegralMethod}</code></pre><p>Generate the appropriate concrete realization of <code>AbstractMeasureData</code> using <code>method</code>. Here <code>prefs</code>, <code>lower_bounds</code>, and <code>upper_bounds</code> will always have a 1 to 1 correspondence when this is called from <code>integral</code>. Please refer to the method docstrings for an explanation of each one.</p><p>User-defined method extensions should first define a concrete <code>method</code> type inheriting from <code>AbstractUnivariateMethod</code> or <code>AbstractMultivariateMethod</code> as appropriate and then implement extend this method using that type for <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8f8712497d400de8a78fab268c70cfcc462ccc29/src/MeasureToolbox/integrals.jl#LL274-L293">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../expression/">« Expressions</a><a class="docs-footer-nextpage" href="../objective/">Objectives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 21 April 2021 20:38">Wednesday 21 April 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
